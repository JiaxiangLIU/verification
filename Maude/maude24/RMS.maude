(fmod MAYBE-NAT is 
  protecting NAT .
  
  sort MaybeNat .
  op none : -> MaybeNat [ctor] .
  op some_ : Nat -> MaybeNat [ctor] .

  vars n m : Nat .

  op s_ : MaybeNat -> MaybeNat .
  eq s none = none .
  eq s some n = some (s n) .

  op _+_ : Nat MaybeNat -> MaybeNat .
  eq n + none = none .
  eq n + some m = some (n + m) .
endfm)

(fmod STACK is 
  protecting MAYBE-NAT .

  sort Stack .
  op bottom : -> Stack [ctor] .
  op _#_ : Nat Stack -> Stack [ctor] .

  var n : Nat .
  var s : Stack .

  op push_to_ : MaybeNat Stack -> Stack .
  eq push none to s = s .
  eq push some n to s = n # s .

  op pop : Stack -> Stack .
  eq pop(bottom) = bottom .
  eq pop(n # s) = s .

  op peek : Stack -> MaybeNat .
  eq peek(bottom) = none .
  eq peek(n # s) = some n .

  op depth : Stack -> Nat .
  eq depth(bottom) = 0 .
  eq depth(n # s) = s (depth(s)) .
endfm)

(tmod COUNTER is
  protecting NAT .
  
  sorts Interval Counter .
  op `[_`,_`] : Time Time -> Interval [ctor] .
  op `[_/_`] : Time Interval -> Counter [ctor] .

  var n : Nat .
  vars m N : NzNat .
  var i : Interval .
  var R R' R'' : Time .

  *** reset the counter
  op reset : Counter -> Counter .
  eq reset([ R / i ]) = [ zero / i ] .

  *** counter may reach the finishing time ?
  op _mayFinish? : Counter -> Bool .
  eq [ R / [ R' , R'' ] ] mayFinish? 
       = if R lt R' then false else true fi .

  op mte : Counter -> Time .
  eq mte([ R / [ R' , R'' ]]) = R'' monus R .

  op delta : Counter Time -> Counter .
  eq delta([ R / i ] , R'') = [ R plus R'' / i ] .
endtm)

(fmod TIMER is
  protecting NAT .
  sort Timer .
  op `[_/_`] : Nat NzNat -> Timer [ctor] .

  var n : Nat .
  vars m N : NzNat .

  *** increase the timer
  op inc : Timer -> Timer .
  ceq inc([ n / N ]) = [ 0 / N ] if s n := N .
  eq inc([ n / N ]) = [ s n / N ] [owise] .

  op _rem_ : Timer NzNat -> Nat .
  eq [ n / N ] rem m = n rem m .
endfm)

(tomod INTERRUPT-SOURCE is
  protecting NAT .

  *** the source of interrupts
  class IntSrc | val : Time , cycle : Time .

  var O : Oid .
  var R R' R'' : Time .
  
  op mte : Object ~> Time .
  eq mte(< O : IntSrc | val : R , cycle : R' >) = R .

  op delta : Object Time ~> Object .
  eq delta(< O : IntSrc | val : R , cycle : R' > , R'')
       = < O : IntSrc | val : R monus R'' , cycle : R' > .
endtom)

(tomod TASK is
  protecting COUNTER .
  class Task | cnt : Counter .

  *** an error status for tasks 
  op error : -> Object [ctor] .
  
  var O : Oid .
  var C : Counter .
  var R : Time .
  
  op _mayFinish? : Object ~> Bool .
  eq < O : Task | cnt : C > mayFinish? = C mayFinish? .

  op mte : Object ~> Time .
  eq mte(error) = zero .
  eq mte(< O : Task | cnt : C >) = mte(C) .

  op delta : Object Time ~> Object .
  eq delta(error, R) = error .
  eq delta(< O : Task | cnt : C > , R) = < O : Task | cnt : delta(C, R) > .
endtom)

(omod PERIODIC-TASK is
  protecting TASK .
  protecting TIMER .
  sort Status .
  ops RUNNING INTERRUPT READY DORMANT : -> Status [ctor] .

  class PTask | priority : Nat , period : NzNat , status : Status .
  subclass PTask < Task .

  var O : Oid .
  var T : Nat . 
  var ST : Status .
  var C : Counter .
  var timer : Timer .

  op updateStatus_with_ : Object Timer ~> Object .
  ceq updateStatus < O : PTask | period : T , status : ST > with timer
        = if ST == DORMANT then < O : PTask | status : READY >
          else error fi
          if timer rem T == 0 .
  eq updateStatus < O : PTask | status : ST > with timer
       = if ST == RUNNING then < O : PTask | status : INTERRUPT >
         else < O : PTask | > fi [owise] .
  eq updateStatus error with timer = error .

  op start_ : Object ~> Object .
  eq start error = error .
  eq start < O : PTask | > = < O : PTask | status : RUNNING > .

  op finish_ : Object ~> Object .
  eq finish error = error .
  eq finish < O : PTask | cnt : C >
       = < O : PTask | status : DORMANT , cnt : reset(C) > .
endom)

(omod TASKLIST is
  protecting MAYBE-NAT .
  protecting PERIODIC-TASK .
  sort TaskList .

  *** List of periodic tasks
  op null : -> TaskList [ctor] .
  op _::_ : Object TaskList ~> TaskList [ctor] .
  mb (< O:Oid : PTask | > :: L:TaskList) : TaskList .
  mb (error :: L:TaskList) : TaskList .

  var n : Nat .
  var t : Object .
  var ST : Status .
  var l : TaskList .
  var timer : Timer .
  var R : Time .

  *** the model of function updateStatus() in the code
  op updateStatus_with_ : TaskList Timer -> TaskList .
  eq updateStatus null with timer = null .
  eq updateStatus t :: l with timer
       = (updateStatus t with timer) :: (updateStatus l with timer) .

  *** find the next task which should be run, from index n
  op nextTaskIn_from_ : TaskList Nat -> MaybeNat .
  eq nextTaskIn null from n = none .
  eq nextTaskIn t :: l from s n = s (nextTaskIn l from n) .
  eq nextTaskIn < O:Oid : PTask | status : ST > :: l from 0 
       = if ST == READY or ST == INTERRUPT 
         then some 0
         else s (nextTaskIn l from 0)
         fi .
  eq nextTaskIn error :: l from 0 = none .

  *** get the status of nth task in l
  op statusOf_in_ : Nat TaskList ~> Status .
  eq statusOf 0 in < O:Oid : PTask | status : ST > :: l = ST .
  eq statusOf s n in t :: l = statusOf n in l .

  *** start nth task in l
  op start_in_ : Nat TaskList ~> TaskList .
  --- eq start n in null = null .
  eq start (s n) in (t :: l) = t :: (start n in l) .
  eq start 0 in (t :: l) = (start t) :: l .

  *** ask whether nth task in l may finish
  op _mayFinish?in_ : Nat TaskList ~> Bool .
  --- eq n mayFinish?in null = false .
  eq (s n) mayFinish?in (t :: l) = n mayFinish?in l .
  eq 0 mayFinish?in (t :: l) = t mayFinish? .

  *** finish nth task in l
  op finish_in_ : Nat TaskList ~> TaskList .
  --- eq finish n in null = null .
  eq finish (s n) in (t :: l) = t :: (finish n in l) .
  eq finish 0 in (t :: l) = (finish t) :: l .

  *** l contains error?
  op containError : TaskList -> Bool .
  eq containError(null) = false .
  eq containError(error :: l) = true .
  eq containError(t :: l) = containError(l) [owise] .

  *** mte of the list l
  op mteOf_in_ : Nat TaskList ~> Time .
  --- eq mteOf n in null = zero .
  eq mteOf 0 in t :: l = mte(t) .
  eq mteOf s n in t :: l = mteOf n in l .

  *** time effect on list l
  op delta : Nat TaskList Time ~> TaskList .
  --- eq delta( n , null , R ) = null .
  eq delta( 0 , (t :: l) , R ) = delta(t , R) :: l .
  eq delta( (s n) , (t :: l) , R ) = t :: delta( n , l , R ) .
endom)

(omod SYSTEM-TASKS is
  protecting TASK .
  protecting MAYBE-NAT .
  sort SysTasks .
  op `[_`] : ObjectConfiguration ~> SysTasks [ctor] .

  sort TaskID .
  subsorts MaybeNat Oid < TaskID .

  ops scheduling switching : -> Oid [ctor] .
endom)

(omod REGISTER is
  protecting SYSTEM-TASKS .
  class Regs | pc : TaskID , mask : Bool ,
               ir : Bool , temp : TaskID .

  var O : Oid .
  var B : Bool .
  var ID : TaskID .

  op _.getPc : Object ~> TaskID .
  eq (< O : Regs | pc : ID >).getPc = ID .

  op _.setPc`(_`) : Object TaskID ~> Object .
  eq (< O : Regs | >).setPc(ID) = < O : Regs | pc : ID > .

  op _.getMask : Object ~> Bool .
  eq (< O : Regs | mask : B >).getMask = B .

  ops _.setMask _.clearMask : Object ~> Object .
  eq (< O : Regs | >).setMask = < O : Regs | mask : true > .
  eq (< O : Regs | >).clearMask = < O : Regs | mask : false > .

  op _.getIr : Object ~> Bool .
  eq (< O : Regs | ir : B >).getIr = B .

  ops _.setIr _.clearIr : Object ~> Object .
  eq (< O : Regs | >).setIr = < O : Regs | ir : true > .
  eq (< O : Regs | >).clearIr = < O : Regs | ir : false > .

  op _.getTemp : Object ~> TaskID .
  eq (< O : Regs | temp : ID >).getTemp = ID .

  op _.setTemp`(_`) : Object TaskID ~> Object .
  eq (< O : Regs | >).setTemp(ID) = < O : Regs | temp : ID > .
endom)

(omod HARDWARE is
  protecting REGISTER .
  protecting STACK .
  sort Hardware .
  op `[_;_`] : Object Stack ~> Hardware [ctor] .
  mb ([ < O:Oid : Regs | > ; S:Stack ]) : Hardware .

  var REGS : Object .
  var S : Stack .

  *** to signal an interrupt request
  op _.intReq : Hardware -> Hardware .
  eq [ REGS ; S ].intReq = [ (REGS).setIr ; S ] .

  *** to handle an interrupt request
  op _.interrupt : Hardware -> Hardware .
  eq [ REGS ; S ].interrupt = [ (((REGS).setMask).clearIr).setPc(scheduling) ;
                                (push (REGS).getPc to S) ] .
  

endom)

(fmod SCHEDULER is
  protecting TASKLIST .
  protecting TIMER .
  sort Scheduler .
  op `[_;_`] : TaskList Timer -> Scheduler [ctor] .
endfm)

(tomod SYSTEM is 
  protecting SCHEDULER .
  protecting SYSTEM-TASKS .
  protecting HARDWARE .
  protecting INTERRUPT-SOURCE .


  op ____ : Scheduler SysTasks Hardware Object ~> System [ctor] .

endtom)

***(
(tmod SCHEDULE is 
  protecting SYSTEM .
  including LTIME .

  op _.updateStatus : System -> System .
  op _.scanTasks : System -> System .
  op _.bgnSchedule : System -> System .
  op _.endSchedule : System -> System .
***  op _.progress : System -> System .
  op _.bgnSwitch : System -> System .
  op _.endSwitch : System -> System .
***  op _.reload : System -> System .

  var tasks : TaskList .
  var s : Stack .
  var r : ThreadID .
  vars m n : Nat .
  var timer : Timer .
  var time : Clock .
  var isTag : IntSwitchTag .
  var irTag : IntReqTag .
  vars schCtr swiCtr : Counter .
  var tmp : MaybeNat .
***  var sTag : SysTag .
  var sys : System .
  vars R R' : Time .

  *** update the status of the tasklist in the system
  eq { tasks ; s ; running r : timer : time 
       | isTag : irTag | schCtr , swiCtr ; tmp }.updateStatus
       = { (updateStatus tasks when timer ) ; s ; running r 
           : inc(timer) : time | isTag : irTag | schCtr , swiCtr ; tmp } .

  *** scan the tasklist to find the first task, whose status is READY or INTERRUPT
  *** - if READY, set the status to be RUNNING and put it to run
  *** - if INTERRUPT, do the "return"
  ceq { tasks ; s ; running r : timer : time 
        | isTag : irTag | schCtr , swiCtr ; tmp }.scanTasks
        = if statusOf n in tasks == READY 
          then { (start n in tasks) ; s ; running some n : timer : time 
                 | INT-ON : irTag | schCtr , swiCtr ; tmp }
          else { tasks ; s ; running r : timer : time 
                 | isTag : irTag | schCtr , swiCtr ; tmp }.int-ret
          *** status of n is INTERRUPT
          fi
          if some n := nextTaskIn tasks from 0 .
  eq { tasks ; s ; running r : timer : time 
       | isTag : irTag | schCtr , swiCtr ; tmp }.scanTasks
       = { tasks ; s ; running none : timer : time 
           | INT-ON : irTag | schCtr , swiCtr ; tmp } [owise] . 
         *** if none := nextTaskIn tasks from 0 .

  *** the schedule function corresponding to the function in the src
  eq (sys).bgnSchedule = (sys).updateStatus .
  eq { tasks ; s ; running sch : timer : time 
       | isTag : irTag | schCtr , swiCtr ; tmp }.endSchedule
       = { tasks ; s ; running sch : timer : time 
           | isTag : irTag | reset(schCtr) , swiCtr ; tmp }.scanTasks .

  *** the whole system progresses 1 tick, advancing the state to IN2
***(
  eq { tasks ; s ; running none : timer : time 
       | isTag : irTag | schCtr , swiCtr ; tmp | sTag }.progress
       = { tasks ; s ; running none : timer : inc(time) 
           | isTag : irTag | schCtr , swiCtr ; tmp | IN2 } .
  eq { tasks ; s ; running some n : timer : time 
       | isTag : irTag | schCtr , swiCtr ; tmp | sTag }.progress
       = { (run n in tasks) ; s ; running some n : timer : inc(time) 
           | isTag : irTag | schCtr , swiCtr ; tmp | IN2 } .
  eq { tasks ; s ; running sch : timer : time 
       | isTag : irTag | schCtr , swiCtr ; tmp | sTag }.progress
       = { tasks ; s ; running sch : timer : inc(time) 
           | isTag : irTag | inc(schCtr) , swiCtr ; tmp | IN2 } .
  eq { tasks ; s ; running swi : timer : time 
       | isTag : irTag | schCtr , swiCtr ; tmp | sTag }.progress
       = { tasks ; s ; running swi : timer : inc(time) 
           | isTag : irTag | schCtr , inc(swiCtr) ; tmp | IN2 } .
  )


  *** to start the switching, store the current finished task ID
  eq { tasks ; s ; running some n : timer : time 
       | isTag : irTag | schCtr , swiCtr ; tmp }.bgnSwitch
       = { tasks ; s ; running swi : timer : time
           | INT-OFF : irTag | schCtr , swiCtr ; some n } . 

  *** to end the switching, set the next task which should be run
  ceq { tasks ; s ; running swi : timer : time 
        | INT-OFF : irTag | schCtr , swiCtr ; some n }.endSwitch
        = if statusOf m in tasks == READY 
          then { (start m in tasks) ; s ; running some m : timer : time 
                 | INT-ON : irTag | schCtr , reset(swiCtr) ; none }
          else { tasks ; s ; running swi : timer : time 
                 | INT-OFF : irTag | schCtr , reset(swiCtr) ; none }.int-ret
          *** status of m is INTERRUPT
          fi
          if some m := nextTaskIn tasks from (s n) .
  eq { tasks ; s ; running swi : timer : time 
       | INT-OFF : irTag | schCtr , swiCtr ; some n }.endSwitch
       = { tasks ; s ; running none : timer : time 
           | INT-ON : irTag | schCtr , reset(swiCtr) ; none } [owise] . 
         *** if none := nextTaskIn tasks from (s n) .


  ***************
  *** instanous rules
  ***************
  rl [req-interrupt] :
    { tasks ; s ; running r : timer : clock( R / R ) 
      | isTag : irTag | schCtr , swiCtr ; tmp } 
    => { tasks ; s ; running r : timer : clock( zero / R ) 
         | isTag : irTag | schCtr , swiCtr ; tmp }.reqInterrupt .

  crl [interrupt] : 
    { tasks ; s ; running r : timer : time 
      | isTag : irTag | schCtr , swiCtr ; tmp } 
    => ({ tasks ; s ; running r : timer : time | isTag : irTag 
          | schCtr , swiCtr ; tmp }.interrupt).bgnSchedule
    if ansInt( isTag , irTag ) == true .

  crl [schedule-finish] :
    { tasks ; s ; running sch : timer : time 
      | isTag : irTag | schCtr , swiCtr ; tmp }
    => { tasks ; s ; running sch : timer : time 
         | isTag : irTag | schCtr , swiCtr ; tmp }.endSchedule
    if (schCtr isFinished? == MAYBE) .

  crl [task-finish] :
    { tasks ; s ; running some n : timer : time 
      | isTag : irTag | schCtr , swiCtr ; tmp }
    => { (finish n in tasks) ; s ; running some n : timer : time 
         | isTag : irTag | schCtr , swiCtr ; tmp }.bgnSwitch
    if (n isFinished?in tasks == MAYBE) .

  crl [switch-finish] :
    { tasks ; s ; running swi : timer : time 
      | isTag : irTag | schCtr , swiCtr ; tmp }
    => { tasks ; s ; running swi : timer : time 
         | isTag : irTag | schCtr , swiCtr ; tmp }.endSwitch
    if (swiCtr isFinished? == MAYBE) .

  ************
  *** max time elapsed
  ************
  op mte : System -> Time [frozen (1)] .
  eq mte({ tasks ; s ; running none : timer : time 
           | isTag : irTag | schCtr , swiCtr ; tmp })
       = if ansInt( isTag , irTag ) then zero
         else mte(time) fi .
  eq mte({ tasks ; s ; running some n : timer : time 
           | isTag : irTag | schCtr , swiCtr ; tmp })
       = if ansInt( isTag , irTag ) then zero
         else minimum( mte(time) , (mteOf n in tasks) ) fi .
  eq mte({ tasks ; s ; running sch : timer : time 
           | isTag : irTag | schCtr , swiCtr ; tmp })
       = if ansInt( isTag , irTag ) then zero
         else minimum( mte(time) , mte(schCtr) ) fi .
  eq mte({ tasks ; s ; running swi : timer : time 
           | isTag : irTag | schCtr , swiCtr ; tmp })
       = if ansInt( isTag , irTag ) then zero
         else minimum( mte(time) , mte(swiCtr) ) fi .

  *************
  *** tick rule
  *************
  crl [tick] : 
    {sys} => {delta(sys, R)} in time R if R le mte(sys) [nonexec] .

  ************
  *** delta effects
  ***********
  op delta : System Time -> System [frozen (1)] .
  eq delta({ tasks ; s ; running none : timer : time
             | isTag : irTag | schCtr , swiCtr ; tmp } , R)
       = { tasks ; s ; running none : timer : delta(time , R)
           | isTag : irTag | schCtr , swiCtr ; tmp } .
  eq delta({ tasks ; s ; running some n : timer : time
             | isTag : irTag | schCtr , swiCtr ; tmp } , R)
       = { delta(n , tasks , R) ; s ; running some n : timer : delta(time , R)
           | isTag : irTag | schCtr , swiCtr ; tmp } .
  eq delta({ tasks ; s ; running sch : timer : time
             | isTag : irTag | schCtr , swiCtr ; tmp } , R)
       = { tasks ; s ; running sch : timer : delta(time , R)
           | isTag : irTag | delta(schCtr , R) , swiCtr ; tmp } .
  eq delta({ tasks ; s ; running swi : timer : time
             | isTag : irTag | schCtr , swiCtr ; tmp } , R)
       = { tasks ; s ; running swi : timer : delta(time , R)
           | isTag : irTag | schCtr , delta(swiCtr , R) ; tmp } .
)

endtom)


(tomod TEST is 
  protecting NAT-TIME-DOMAIN .
  including SYSTEM-TASKS .
  inc TASKLIST .
  inc SYSTEM .
  protecting QID .

  subsort Qid < Oid .

  ops o1 o2 : -> Object .
  ops regs isrc : -> Object .

  eq regs = < 'r : Regs | pc : scheduling , mask : true ,
               ir : false , temp : none > .
  eq isrc = < 'i : IntSrc | val : 4 , cycle : 500 > .

  eq o1 = < 'o1 : PTask | cnt : [ 1 / [2 , 4]] , period : 1 ,
                          priority : 1 , status : READY > .

  ops L-1 L-2 : -> TaskList .

  eq L-1 = error 
           :: < 'o1 : PTask | priority : 5 , period : 16 ,
	                      status : RUNNING , cnt : [ 3 / [ 3 , 5 ] ] >
           :: < 'o2 : PTask | priority : 4 , period : 8 ,
                              status : INTERRUPT , cnt : [ 2 / [ 3 , 5 ] ] > 
           :: < 'o3 : PTask | priority : 3 , period : 4 ,
                              status : READY , cnt : [ 4 / [ 3 , 5] ] >
           :: < 'o4 : PTask | priority : 2 , period : 2 ,
                              status : DORMANT , cnt : [ 1 / [ 3 , 5 ] ] > 
           :: null .

  eq L-2 = < 'o1 : PTask | priority : 5 , period : 16 ,
	                   status : RUNNING , cnt : [ 3 / [ 3 , 5 ] ] >
           :: < 'o2 : PTask | priority : 4 , period : 8 ,
                              status : INTERRUPT , cnt : [ 2 / [ 3 , 5 ] ] > 
           :: < 'o3 : PTask | priority : 3 , period : 4 ,
                              status : READY , cnt : [ 4 / [ 3 , 5] ] >
           :: < 'o4 : PTask | priority : 2 , period : 2 ,
                              status : DORMANT , cnt : [ 1 / [ 3 , 5 ] ] > 
           :: null .
	   
***(
  eq EXAM-2 = < priority 5 , period 20 , RUNNING : [ 4 / [ 3 , 5 ] ] > 
              :: < priority 4 , period 15 , INTERRUPT : [ 5 / [ 3 , 5 ] ] > 
              :: < priority 3 , period 10 , READY : [ 2 / [ 3 , 5 ] ] >
              :: < priority 2 , period 5 , DORMANT : [ 2 / [ 3 , 5 ] ] > 
              :: null .

  ops SYS-1 SYS-2 : -> System .

  eq SYS-1 = { EXAM-2 ; 1 # bottom ; running some 1  : [ 1 / 2] : clock( 4 / 5 ) 
               | INT-ON : intReq false | [ 0 / [ 1 , 2 ] ] , [ 3 / [ 3 , 4 ] ] ; 
               some 0 } .
  eq SYS-2 = { EXAM-2 ; 1 # bottom ; running some 0 : [ 1 / 2] : clock( 3 / 5 ) 
               | INT-OFF : intReq true | [ 0 / [ 1 , 2 ] ] , [ 0 / [ 3 , 4 ] ] ; 
               none } .

  ops TEST-1 TEST-2 TEST-3 TEST-4 : -> TaskList .
  ops INIT-1 INIT-2 INIT-3 INIT-4 : -> System .
  ops TASK-614-1 TASK-614-2 TASK-614-3 TASK-614-4 : -> TaskList .
  ops INIT-614-1 INIT-614-2 INIT-614-3 INIT-614-4 : -> System .
  ops TEST-5 TEST-6 : -> TaskList .
  ops INIT-5 INIT-6 : -> System .

  *** utilization = 71.6%
  eq TEST-1 = < priority 8 , period 2 , DORMANT : [ 0 / [ 100 , 100 ] ] >
            :: < priority 7 , period 4 , DORMANT : [ 0 / [ 300 , 300 ] ] >
            :: < priority 6 , period 7 , DORMANT : [ 0 / [ 300 , 300 ] ] >
            :: < priority 5 , period 11 , DORMANT : [ 0 / [ 400 , 400 ] ] >
            :: < priority 4 , period 14 , DORMANT : [ 0 / [ 500 , 500 ] ] >
            :: < priority 3 , period 18 , DORMANT : [ 0 / [ 800 , 800 ] ] >
            :: < priority 2 , period 22 , DORMANT : [ 0 / [ 700 , 700 ] ] >
            :: < priority 1 , period 24 , DORMANT : [ 0 / [ 1000 , 1000 ] ] >
            :: null .

  eq TEST-2 = < priority 8 , period 2 , DORMANT : [ 0 / [ 1 , 1 ] ] >
            :: < priority 7 , period 4 , DORMANT : [ 0 / [ 3 , 3 ] ] >
            :: < priority 6 , period 7 , DORMANT : [ 0 / [ 3 , 3 ] ] >
            :: < priority 5 , period 11 , DORMANT : [ 0 / [ 4 , 4 ] ] >
            :: < priority 4 , period 14 , DORMANT : [ 0 / [ 5 , 5 ] ] >
            :: < priority 3 , period 18 , DORMANT : [ 0 / [ 8 , 8 ] ] >
            :: < priority 2 , period 22 , DORMANT : [ 0 / [ 7 , 7 ] ] >
            :: < priority 1 , period 24 , DORMANT : [ 0 / [ 60 , 60 ] ] >
            :: null .

  eq TEST-3 = < priority 8 , period 2 , DORMANT : [ 0 / [ 50 , 100 ] ] >
            :: < priority 7 , period 4 , DORMANT : [ 0 / [ 200 , 250 ] ] >
            :: < priority 6 , period 7 , DORMANT : [ 0 / [ 200 , 300 ] ] >
            :: < priority 5 , period 11 , DORMANT : [ 0 / [ 300 , 400 ] ] >
            :: < priority 4 , period 14 , DORMANT : [ 0 / [ 200 , 400 ] ] >
            :: < priority 3 , period 18 , DORMANT : [ 0 / [ 500 , 700 ] ] >
            :: < priority 2 , period 22 , DORMANT : [ 0 / [ 400 , 600 ] ] >
            :: < priority 1 , period 24 , DORMANT : [ 0 / [ 600 , 750 ] ] >
            :: null .

  eq TEST-4 = < priority 8 , period 2 , DORMANT : [ 0 / [ 1 , 2 ] ] >
            :: < priority 7 , period 4 , DORMANT : [ 0 / [ 2 , 3 ] ] >
            :: < priority 6 , period 7 , DORMANT : [ 0 / [ 2 , 4 ] ] >
            :: < priority 5 , period 11 , DORMANT : [ 0 / [ 3 , 4 ] ] >
            :: < priority 4 , period 14 , DORMANT : [ 0 / [ 2 , 5 ] ] >
            :: < priority 3 , period 18 , DORMANT : [ 0 / [ 5 , 8 ] ] >
            :: < priority 2 , period 22 , DORMANT : [ 0 / [ 4 , 7 ] ] >
            :: < priority 1 , period 24 , DORMANT : [ 0 / [ 10 , 60 ] ] >
            :: null .

  eq TEST-5 = < priority 1 , period 1 , DORMANT : [ 0 / [ 1 , 6 ] ] >
            :: null .

  eq TEST-6 = < priority 2 , period 1 , DORMANT : [ 0 / [ 1 , 3 ] ] >
              :: < priority 1 , period 2 , DORMANT : [ 0 / [ 2 , 5 ] ] >
              :: null .

  eq TASK-614-1 = < priority 2 , period 1 , DORMANT : [ 0 / [ 3000 , 3000 ] ] >
                  :: < priority 1 , period 5 , DORMANT : [ 0 / [ 7000 , 7000 ] ] >
                  :: null .

  eq TASK-614-2 = < priority 2 , period 1 , DORMANT : [ 0 / [ 2000 , 2000 ] ] >
                  :: < priority 1 , period 5 , DORMANT : [ 0 / [ 4000 , 4000 ] ] >
                  :: null .

  eq TASK-614-3 = < priority 2 , period 1 , DORMANT : [ 0 / [ 2000 , 2000 ] ] >
                  :: < priority 1 , period 5 , DORMANT : [ 0 / [ 2300 , 2300 ] ] >
                  :: null .

  eq TASK-614-4 = < priority 2 , period 1 , DORMANT : [ 0 / [ 2500 , 3000 ] ] >
                  :: < priority 1 , period 5 , DORMANT : [ 0 / [ 7000 , 7000 ] ] >
                  :: null .

  eq INIT-1 = { TEST-1 ; bottom ; running none : [ 0 / CYCLE ] : clock( 0 / 13860000 ) 
                | INT-ON : intReq false 
                | [ 0 / [ 3 , 4 ] ] , [ 0 / [ 1 , 2 ] ] ; none } .
  eq INIT-2 = { TEST-2 ; bottom ; running none : [ 0 / CYCLE ] : clock( 0 / CYCLE )
                | INT-ON : intReq false 
                | [ 0 / [ 1 , 1 ] ] , [ 0 / [ 1 , 1 ] ] ; none } .
  eq INIT-3 = { TEST-3 ; bottom ; running none : [ 0 / CYCLE ] : clock( 0 / 13860000 )
                | INT-ON : intReq false 
                | [ 0 / [ 3 , 4 ] ] , [ 0 / [ 1 , 2 ] ] ; none } .
  eq INIT-4 = { TEST-4 ; bottom ; running none : [ 0 / CYCLE ] : clock( 0 / CYCLE )
                | INT-ON : intReq false 
                | [ 0 / [ 1 , 1 ] ] , [ 0 / [ 1 , 1 ] ] ; none } .
  eq INIT-5 = { TEST-5 ; bottom ; running none : [ 0 / 2 ] : clock( 0 / 10 )
                | INT-ON : intReq false 
                | [ 0 / [ 1 , 1 ] ] , [ 0 / [ 1 , 1 ] ] ; none } .
  eq INIT-6 = { TEST-6 ; bottom ; running none : [ 0 / 2 ] : clock( 0 / 10 )
                | INT-ON : intReq false 
                | [ 0 / [ 1 , 1 ] ] , [ 0 / [ 1 , 1 ] ] ; none } .
  eq INIT-614-1 = { TASK-614-1 ; bottom ; running none : [ 0 / 5 ] : clock( 5000 / 5000 )
                    | INT-ON : intReq false 
                    | [ 0 / [ 5 , 9 ] ] , [ 0 / [ 2 , 4 ] ] ; none } .
  eq INIT-614-2 = { TASK-614-2 ; bottom ; running none : [ 0 / 5 ] : clock( 0 / 5000 )
p                    | INT-ON : intReq false 
                    | [ 0 / [ 5 , 9 ] ] , [ 0 / [ 2 , 4 ] ] ; none } .
  eq INIT-614-3 = { TASK-614-3 ; bottom ; running none : [ 0 / 5 ] : clock( 0 / 5000 )
                    | INT-ON : intReq false 
                    | [ 0 / [ 5 , 9 ] ] , [ 0 / [ 2 , 4 ] ] ; none } .
  eq INIT-614-4 = { TASK-614-4 ; bottom ; running none : [ 0 / 5 ] : clock( 5000 / 5000 )
                    | INT-ON : intReq false 
                    | [ 0 / [ 2 , 2 ] ] , [ 0 / [ 1 , 1 ] ] ; none } .
)
endtom)

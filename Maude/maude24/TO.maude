(fmod TO-STATUS is
    --- system status
    sort SystemStatus .
    ops SYS-INIT SYS-FAULT SYS-MAINTENANCE SYS-LAUNCHED SYS-STANDBY
	SYS-NORMAL SYS-AUTOCONTROL SYS-MAX : -> SystemStatus .

    --- trip status
    sort TripStatus .
    ops TRIP-DATA-RECVING TRIP-DATA-COMPLETE TRIP-MARSHALLING-CONFIRM 
	TRIP-INIT TRIP-START TRIP-PAUSE TRIP-COMPLETE TRIP-ANOMALY 
	TRIP-MAX : -> TripStatus .

    --- fsm states
    sort FsmState .
    ops FSM-MANUAL FSM-START-AUTO FSM-ACK-AUTO FSM-OVER-TIME FSM-AUTO
	FSM-START-MANUAL FSM-ACK-MANUAL FSM-ERGE-AUTO : -> FsmState .
    
    --- the sources where the events come
    sort EventSource .
    ops SOURCE-COM SOURCE-CORE SOURCE-CONTROL SOURCE-VOTE
	SOURCE-INPUT SOURCE-OUTPUT MAX-SOURCE : -> EventSource .

    --- control status
    sort ControlStatus .
    ops CONTROL-MANNUL CONTROL-AUTO : -> ControlStatus .

    --- events
    sort EventType .

    --- events on COMM
    ops EVENT-COM-HEARTBEAT EVENT-COM-REGISTER EVENT-LKJ-VERSION-DIFFERENCE
	EVENT-TRIP-STATUS-NOTICE EVENT-DUTY-ASSISTING-CHANGE
	EVENT-ROUTE-DATA-SEND EVENT-ROUTE-DATA-CURVE EVENT-ROUTE-DATA-LIMIT
	EVENT-ROUTE-DATA-TELESEME EVENT-ROUTE-DATA-TUNNEL EVENT-ROUTE-DATA-STATION
	EVENT-FRONT-SPEED-LIMIT EVENT-FRONT-BRANCH-TRANSFER EVENT-FRONT-SIDE-LINE-PASS
	EVENT-MARSHALLING-RE-CHANGE EVENT-REAL-TIME-INFO EVENT-ROUTE-VERSION-SEND
	EVENT-TRIP-CHANGE EVENT-MARSHALLING-CHANGE EVENT-CLOCK-SYNC
	EVENT-REAL-TIME-ERROR EVENT-BASE-LINE-DATA-ERROR EVENT-ROUTE-EXTRACT-FAILUER
	EVENT-MARSHALLING-ERROR EVENT-STATION-ERROR EVENT-COM-EXTERNAL-CAN-FAULT
	EVENT-COM-INTERNAL-CAN-FAULT EVENT-COM-MAX : -> EventType .

    --- events on CORE
    ops EVENT-CORE-HEARTBEAT EVENT-CORE-REGISTER EVENT-ROUTE-VERSION-RESULT
	EVENT-TRIP-OPT-COMPLETE EVENT-ROUTE-DATA-SEND-ACK EVENT-ROUTE-DATA-CURVE-ACK
	EVENT-ROUTE-DATA-LIMIT-ACK EVENT-ROUTE-DATA-TELESEME-ACK EVENT-ROUTE-DATA-TUNNEL-ACK
	EVENT-ROUTE-DATA-STATION-ACK EVENT-REAL-TIME-CTRL EVENT-CORE-CAN-FAULT
	EVENT-TRIP-ROUTE-ERROR EVENT-TRIP-POSITION-ERROR EVENT-TRIP-PARA-ERROR
	EVENT-TRIP-OPT-ERROR EVENT-TEMP-OPT-ERROR EVENT-CORE-MAX : -> EventType .

    --- events on Control-Box
    ops EVENT-CTRL-BOX-HEARTBEAT EVENT-CTRL-BOX-REGISTER EVENT-CTRL-BOX-MASTER-SET
	EVENT-CTRL-BOX-MASTER-RELIEVE EVENT-TRIP-INIT-START EVENT-MANNAL-TO-AUTO
	EVENT-AUTO-TO-MANNAL EVENT-TWO-GEAR-TO-MANNUL EVENT-SYS-TO-MAINTENANCE
	EVENT-EXIT-MAINTENANCE EVENT-KEEP-AUTO EVENT-KEEP-MANNAL
	EVENT-SEND-AUTO-GEAR EVENT-GEAR8-AUTO-CONFIRM-ACK EVENT-TRIP-OVER
	EVENT-VOTE-HEARTBEAT-STOP EVENT-CTRL-BOX-CAN-FAULT EVENT-CTRL-BOX-PARSE-ERROR
	EVENT-CTRL-MAX : -> EventType .

    --- events on VOTE
    ops EVENT-VOTE-HEARTBEAT EVENT-BROADCAST-COM-ADDR EVENT-MASTER-VOTE-EXCHANGE
	EVENT-LOCK-SCREEN EVENT-VOTE-TRIP-INIT-START EVENT-SYS-TRIP-STATUS-SEND
	EVENT-MANNAL-GEAR-CHANGE EVENT-TWO-GEAR-CONFIRM EVENT-MANNAL-COMPLETE
	EVENT-AUTO-COMPLETE EVENT-BRANCH-TRANSFER-TIME EVENT-SPEED-LIMIT-TIME
	EVENT-SIG-CHANGE-TIME EVENT-AUTO-TIME-ALARM EVENT-MANNUL-TIME-ALARM
	EVENT-BRAKE-GEAR0 EVENT-GEAR8-AUTO-CONFIRM EVENT-VOTE-UPDATE-MARSHALLING
	EVENT-VOTE-SENT-MARSHALLING EVENT-DISP-AUTO EVENT-DISP-MANNAL
	EVENT-DISP-REAL-TIME-INFO EVENT-VOTE-TRIP-INIT-COMPLETE EVENT-VOTE-BRANCH-TRANSFER-PASS
	EVENT-VOTE-SIDE-LINE-PASS-START EVENT-VOTE-SIDE-LINE-PASS-END EVENT-TRIP-UPDATE
	EVENT-SEND-TRIP-TO-CORE EVENT-MAR-UPDATE EVENT-SEND-MAR-TO-CORE
	EVENT-BOARD-REGISTER-FAILUER EVENT-MASTER-COM-HEARTBEAT-STOP EVENT-ALL-COM-HEARTBEAT-STOP
	EVENTH-CORE-HEARTBEAT-STOP EVENT-MASTER-CTRL-HEARTBEAT-STOP EVENT-RELAY-FAULT
	EVENT-COM-FAULT-HANDLE EVENT-CORE-FAULT-HANDLE EVENT-CTRL-FAULT-HANDLE
	EVENT-VOTE-FAULT-HANDLE EVENT-VOTE-MAX : -> EventType .

    --- events on INPUT
    ops EVENT-DIGITAL-ANALOG EVENT-INPUT-MAX : -> EventType .

    --- events on OUTPUT
    ops EVENT-HEARTBEAT-STOP EVENT-OUTPUT-MAX : -> EventType .    

endfm)

(omod VALUE is
    protecting TO-STATUS .
    sort Value .

    subsort Nat < Value .
    subsort EventSource < Value .
    subsort Oid < Value .
    subsort SystemStatus < Value .
    subsort TripStatus < Value .
    subsort FsmState < Value .
    op null : -> Value .
endom)
    
(omod COMMAND is
    protecting TO-STATUS .
    protecting VALUE .
    sort Command .

    op _|_|_ : EventSource EventType Value -> Command [ctor] .

endom)

(omod DATA is
    protecting TO-STATUS .
    protecting VALUE .
    sort Data .

    op _|_|_|_|_ : EventSource EventType Value Nat Nat -> Data [ctor] .

endom)
            
(omod FRAME is
    protecting COMMAND .
    protecting DATA .
    protecting VALUE .
    sort Frame .
    sorts DataFrame CommandFrame .
    subsorts DataFrame CommandFrame < Frame .
    subsort Value < Frame .
    
    op command : Command -> CommandFrame [ctor] .
    op data : Data -> DataFrame [ctor] .

    sort MaybeFrame .
    op none : -> MaybeFrame [ctor] .
    op some_ : Frame -> MaybeFrame [ctor] .

endom)
    
(omod SOCKET is
    protecting NAT .
    protecting FRAME .
    sort SocketType .
    sort PortType .
    subsort SocketType < PortType .

    --- define a msg to send frames to some socket port
    msg `[==>_:_|_`] : Oid PortType MaybeFrame -> Msg .

    op SOCKET-TYPE-0 : -> SocketType [ctor] . --- 0x80
    op SOCKET-TYPE-1 : -> SocketType [ctor] . --- 0x40
    op SOCKET-TYPE-2 : -> SocketType [ctor] . --- 0x20
    op SOCKET-TYPE-3 : -> SocketType [ctor] . --- 0x10
    op SOCKET-TYPE-4 : -> SocketType [ctor] . --- 0x08
    op SOCKET-TYPE-5 : -> SocketType [ctor] . --- 0x04
    op SOCKET-TYPE-CAN2NET : -> SocketType [ctor] . --- 0x02
    op COM-SOC : -> SocketType . --- 0x20
    op DAT-SOC : -> SocketType . --- 0x04
    op DAT-VOTE-SOC : -> SocketType . --- 0x08

    op PORT-CANINOUT : -> PortType [ctor] . --- for cssl in CAN-INOUT
    op PORT-LKJ : -> PortType [ctor] . --- for communication between LKJ and COMM

    eq COM-SOC = SOCKET-TYPE-2 .
    eq DAT-SOC = SOCKET-TYPE-5 .
    eq DAT-VOTE-SOC = SOCKET-TYPE-4 .
endom)

    ***(
(omod QUEUE is
    protecting FRAME .
    sort Queue .

    pr NAT .
    subsort Nat < Frame .

    op nil : -> Queue [ctor] .
    op _::_ : Frame Queue -> Queue [ctor] .

    vars F F' : Frame .
    var Q : Queue .

    --- operation _peek_ requires the Queue to be not empty
    op peek : Queue -> Frame .
    eq peek(F :: Q) = F .

    op enqueue : Frame Queue -> Queue .
    eq enqueue(F, nil) = F :: nil .
    eq enqueue(F, F' :: Q) = F' :: enqueue(F, Q) .

    op dequeue : Queue -> Queue .
    eq dequeue(nil) = nil .
    eq dequeue(F :: Q) = Q .
endom)

(omod BUFFER is
    protecting QUEUE .
    sort Buffer .
    subsort Queue < Buffer .
endom)
    )

(omod MEMORY is
    protecting QID .
    protecting VALUE .
    sort Memory .
    sorts Variable Pair .
    subsort Qid < Variable .

    op `(_->_`) : Variable Value -> Pair [ctor] .

    op empty : -> Memory [ctor] .
    subsort Pair < Memory .
    op _`,_ : Memory Memory -> Memory [ctor assoc comm id: empty] .

    var X : Variable .
    vars V V' : Value .
    var M : Memory .

    --- assignment
    op _`[_:=_`] : Memory Variable Value -> Memory .
    eq ((X -> V), M)[X := V'] = (X -> V'), M .
    eq M[X := V'] = (X -> V'), M [owise] .

    --- evaluation
    op _`[_`] : Memory Variable -> Value .
    eq ((X -> V), M)[X] = V .
    eq M[X] = null [owise] .

endom)

(omod THREAD is
    sort ThreadID .
    subsort ThreadID < Oid .

    sort Status .
    
    class Thread | st : Status .
endom)

(omod THREADPOOL is
    protecting THREAD .
    sort ThreadPool .

    op empty : -> ThreadPool [ctor] .
    op _;_ : Object ThreadPool -> ThreadPool [ctor] .

    ops a b c : -> Object .

    vars O O' : Object .
    var P : ThreadPool .
    
    --- operation _peek_ requires the Pool to be not empty
    op peek : ThreadPool -> Object .
    eq peek(O ; P) = O .

    op enqueue : Object ThreadPool -> ThreadPool .
    eq enqueue(O, empty) = O ; empty .
    eq enqueue(O, O' ; P) = O' ; enqueue(O, P) .

    op dequeue : ThreadPool -> ThreadPool .
    eq dequeue(empty) = empty .
    eq dequeue(O ; P) = P .
endom)

(fmod RT-CORE is
    protecting TO-STATUS .
    protecting VALUE .
    protecting NAT .
    sort RtCore .
    subsort RtCore < Value .

    op `(rt-gear:_`,rt-enable-status:_`) : Nat Nat -> RtCore [ctor] .

    vars N M : Nat .

    op _.rt-gear : RtCore -> Nat .
    eq ((rt-gear: N ,rt-enable-status: M )).rt-gear = N .

    op _.rt-enable-status : RtCore -> Nat .
    eq ((rt-gear: N ,rt-enable-status: M )).rt-enable-status = M .    
endfm)

(fmod RT-VOTE is
    protecting TO-STATUS .
    protecting VALUE .
    protecting RT-CORE .
    protecting NAT .
    sort RtVote .
    subsort RtVote < Value .
    
    op `(rt-core:_`,rt-control-status:_`) : RtCore ControlStatus -> RtVote [ctor] .

    var RT : RtCore .
    var CS : ControlStatus .
    
    op _.rt-core : RtVote -> RtCore .
    eq ((rt-core: RT ,rt-control-status: CS )).rt-core = RT .

    op _.rt-control-status : RtVote -> ControlStatus .
    eq ((rt-core: RT ,rt-control-status: CS )).rt-control-status = CS .
endfm)

(fmod THROTTLE-GEAR is
    protecting TO-STATUS .
    protecting VALUE .
    protecting NAT .
    protecting FRAME .
    sort ThrottleGear .
    subsort ThrottleGear < Value .
    subsort ThrottleGear < Frame .

    op `(gear:_`,auto-or-manual:_`) : Nat Nat -> ThrottleGear [ctor] .

    vars N M : Nat .
    
    op _.gear : ThrottleGear -> Nat .
    eq (gear: N ,auto-or-manual: M ).gear = N .

    op _.auto-or-manual : ThrottleGear -> Nat .
    eq (gear: N ,auto-or-manual: M ).auto-or-manual = M .
endfm)
    
(omod BOARD is
---    protecting BUFFER .
    protecting MEMORY .
    protecting THREADPOOL .

    class Board | cpu : Object, mem : Memory, pool : ThreadPool .

    op ideal : -> Object .

    ops CON-DES COM-DES CORE-DES VOTE-DES OUT-DES IN-DES : -> Oid .

endom)

(omod COMM is
    protecting TO-STATUS .
    protecting BOARD .
    protecting SOCKET .    

    class Comm .
    subclass Comm < Board .
    
    vars O O' : Oid .
    var S : SocketType .
    var N : Nat .
    var M : Memory .
    vars T T' : Object .
    var P : ThreadPool .
    var F : Frame .
    subsort Nat < Oid .
    var OB : Object .
    var C : Command .
    var NEW : Object .
    var CON : Configuration .
    var D : Data .
    var V : Value .
    var SYSST : SystemStatus .
    var TRIPST : TripStatus .
    vars AMOUNT CNT : Nat .
    
    op msg1 : Oid Nat -> Msg .
    op cpu1 : -> Object .
    op mem1 : -> Memory .
    op pool1 : -> ThreadPool .
    op ftest : -> Frame .
    op com1 : -> Command .
    op data1 : -> Data .
    ops a b c : -> Object .

    --- threads
    op socket-rcv : SocketType -> ThreadID [ctor] .

    ops rt-main main : -> ThreadID [ctor] .
    op command-frame-rcv-handle : -> ThreadID .
    
    op read : -> Status .
    op comm-frame-parse : Frame -> Status .
    op threadpool-add : ThreadID Command -> Status .
    op comm-data-frame-rcv-handle : Data -> Status .
    op done : -> Status .

    --- rl [schedule] :
    --- assume this transition is instantaneous
    eq < O : Comm | cpu : ideal, pool : (T ; P) > = < O : Comm | cpu : T, pool : P > .

    ***********************************************
    *** behavior of thread socket_rcv
    ***********************************************
    
    --- wait to read msgs, if existing, then read
    crl [comm-socket-rcv-n-read-some] :
	< O : Comm | cpu : T, pool : P >
      	[==> O : S | some F ]
      => < O : Comm | cpu : ideal, pool : enqueue(T', P) >
	[==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T
	  /\ T' := < socket-rcv(S) : Thread | st : comm-frame-parse(F) > .

    --- wait to read msgs, if not exisiting, then switch
    crl [comm-socket-rcv-n-read-none] :
	< O : Comm | cpu : T, pool : P > [==> O : S | none ]
      => < O : Comm | cpu : ideal, pool : enqueue(T, P) > [==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T .

    --- parse frames, including commands and data
    eq comm-frame-parse(command(C)) = threadpool-add(command-frame-rcv-handle, C) .
    eq comm-frame-parse(data(D)) = comm-data-frame-rcv-handle(D) .

    op comm-handle : Command -> Status .

    --- create a new thread in pool to handle commands, then return to while loop reading
    crl [comm-threadpool-add-command] :
	< O : Comm | cpu : T, pool : P >
      => < O : Comm | cpu : ideal, pool : enqueue(T', enqueue(NEW, P)) >
      if < socket-rcv(S) : Thread | st : threadpool-add(command-frame-rcv-handle, C) > := T
	  /\ T' := < socket-rcv(S) : Thread | st : read >
	  /\ NEW := < command-frame-rcv-handle : Thread | st : comm-handle(C) > .

    --- definition of "done" status of the thread socekt_rcv():
    --- back to loop reading
    eq < socket-rcv(S) : Thread | st : done >
      = < socket-rcv(S) : Thread | st : read > .

    --- testing
    op test : Nat -> Configuration .
    eq test(55) = < COM-DES : Comm | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : a ; empty >
	[==> COM-DES : SOCKET-TYPE-2 | none ]  .
    eq test(56) = < COM-DES : Comm | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : empty >
	[==> COM-DES : SOCKET-TYPE-2 | some command(com1) ]  .
    eq test(57) = < COM-DES : Comm | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : empty >
	[==> COM-DES : SOCKET-TYPE-2 | some data(data1) ]  .        


    **********************************************
    *** behavior of data_frame_rcv_handle
    **********************************************
    
    eq comm-data-frame-rcv-handle( S:EventSource | E:EventType | V | AMOUNT | CNT )
      = done .
    *** DONE for COMM

    --- testing
    eq test(58) = < COM-DES : Comm | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : empty >
	[==> COM-DES : SOCKET-TYPE-2
	  | some data( SOURCE-CORE | EVENT-REAL-TIME-INFO | 9 | 0 | 1 ) ]  .
    

    **********************************************
    *** behavior of command_frame_rcv_handle
    **********************************************

    op set-commu-addr : Oid -> Status .
    op set-sys-status : SystemStatus -> Status .
    op set-trip-status : TripStatus -> Status .
      
    --- definition of handle
    *** all events from SOURCE-VOTE are omitted
    *** all events from SOURCE-CORE are omitted
    eq comm-handle( S:EventSource | E:EventType | V ) = done .
    *** DONE for COMM 

    --- thread command_frame_rcv_handle done
    crl [comm-command-frame-rcv-handle-done] :
	< O : Comm | cpu : T > => < O : Comm | cpu : ideal >
      if < command-frame-rcv-handle : Thread | st : done > := T .
    
    --- testing
    eq test(59) = < COM-DES : Comm | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : empty >
	[==> COM-DES : SOCKET-TYPE-2
	  | some command( SOURCE-CORE | EVENT-REAL-TIME-INFO | 1 ) ]  .


    ************************************************
    *** behavior of net_thread
    ************************************************

    op net-thread : -> ThreadID .
    op wait-to-send : -> Status .

    --- wait to read msgs, if existing, then read
    crl [comm-net-thread-read-some] :
	< O : Comm | cpu : T, mem : M, pool : P >
      	[==> O : PORT-LKJ | some V ]
      => < O : Comm | cpu : ideal, mem : M['to-send := V], pool : enqueue(T', P) >
	[==> O : PORT-LKJ | none ]
      if < net-thread : Thread | st : read > := T
	  /\ T' := < net-thread : Thread | st : wait-to-send > .

    --- wait to read msgs, if not exisiting, then switch
    crl [comm-net-thread-read-none] :
	< O : Comm | cpu : T, pool : P > [==> O : PORT-LKJ | none ]
      => < O : Comm | cpu : ideal, pool : enqueue(T, P) > [==> O : PORT-LKJ | none ]
      if < net-thread : Thread | st : read > := T .

    --- behavior of wait-to-send
    crl [comm-wait-to-send-succ] :
	< O : Comm | cpu : T, mem : M, pool : P >
      	[==> CORE-DES : SOCKET-TYPE-1 | none ]
      => < O : Comm | cpu : ideal, pool : enqueue(T', P) >
	[==> CORE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-REAL-TIME-INFO | M['to-send] | 0 | 0 ) ]
      if < net-thread : Thread | st : wait-to-send > := T
	  /\ T' := < net-thread : Thread | st : read > .
    crl [comm-wait-to-send-block] :
	< O : Comm | cpu : T, mem : M, pool : P >
      	[==> CORE-DES : SOCKET-TYPE-1 | some F ]
      => < O : Comm | cpu : ideal, pool : enqueue(T, P) >
	[==> CORE-DES : SOCKET-TYPE-1 | some F ]
      if < net-thread : Thread | st : wait-to-send > := T .
     

    --- testing
    eq test(61) = < COM-DES : Comm | cpu : < net-thread : Thread | st : read >,
	mem : mem1, pool : empty >
	[==> COM-DES : PORT-LKJ | some 124 ]
        [==> CORE-DES : SOCKET-TYPE-1 | none ] .
    eq test(62) = < COM-DES : Comm | cpu : < net-thread : Thread | st : read >,
	mem : mem1, pool : pool1 >
	[==> COM-DES : PORT-LKJ | none ]  .
    eq test(63) = < COM-DES : Comm | cpu : < net-thread : Thread | st : read >,
	mem : mem1, pool : empty >
	[==> COM-DES : PORT-LKJ | some 124 ]
        [==> CORE-DES : SOCKET-TYPE-1 | some 0 ] .    
    
endom)

(omod CORE is
    protecting TO-STATUS .
    protecting BOARD .
    protecting SOCKET .

    class Core .
    subclass Core < Board .

    --- threads
    op socket-rcv : SocketType -> ThreadID [ctor] .
    ops rt-main main : -> ThreadID [ctor] .
    op command-frame-rcv-handle : -> ThreadID .
    
    op read : -> Status .
    op core-frame-parse : Frame -> Status .
    op threadpool-add : ThreadID Command -> Status .
    op core-data-frame-rcv-handle : Data -> Status .
    op done : -> Status .

    
    vars O O' : Oid .
    var S : SocketType .
    var N : Nat .
    var M : Memory .
    vars T T' : Object .
    var P : ThreadPool .
    var F : Frame .
    subsort Nat < Oid .
    var OB : Object .
    var C : Command .
    var NEW : Object .
    var CON : Configuration .
    var D : Data .
    var V : Value .
    var SYSST : SystemStatus .
    var TRIPST : TripStatus .
    vars AMOUNT CNT : Nat .
    
    op msg1 : Oid Nat -> Msg .
    op cpu1 : -> Object .
    op mem1 : -> Memory .
    op pool1 : -> ThreadPool .
    op ftest : -> Frame .
    op com1 : -> Command .
    op data1 : -> Data .
    ops a b c : -> Object .

    ops test1 test2 test3 test4 test5 test6 : -> Configuration .
    ops test7 test8 test9 : -> Configuration .
    eq test1 = < 1 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : a ; empty >
	[==> 1 : SOCKET-TYPE-2 | none ]  .
    eq test2 = < 2 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : ('master-commu-addr -> SOURCE-COM), pool : empty >
	[==> 2 : SOCKET-TYPE-2
	  | some command( SOURCE-VOTE | EVENT-BROADCAST-COM-ADDR | SOURCE-COM ) ]  .    
    eq test3 = < 3 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : empty >
	[==> 3 : SOCKET-TYPE-2 | some data(data1) ]  .
    eq test4 = < 4 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('master-commu-addr -> SOURCE-COM), ('sys-status -> SOURCE-COM)), 
	pool : empty >
	[==> 4 : SOCKET-TYPE-2
	  | some command( SOURCE-VOTE | EVENT-MASTER-VOTE-EXCHANGE | SYS-LAUNCHED ) ]  .
    eq test5 = < 5 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('trip-status -> SOURCE-COM), ('sys-status -> SOURCE-COM)), 
	pool : empty >
	[==> 5 : SOCKET-TYPE-2
	  | some command( SOURCE-VOTE | EVENT-SYS-TRIP-STATUS-SEND | TRIP-START ) ]  .
    eq test6 = < 6 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('trip-status -> SOURCE-COM), ('sys-status -> SOURCE-COM)), 
	pool : empty >
	[==> 6 : SOCKET-TYPE-2
	  | some command( SOURCE-COM | EVENT-SYS-TRIP-STATUS-SEND | TRIP-START ) ]  .
    eq test7 = < 7 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('trip-status -> SOURCE-COM), ('sys-status -> SOURCE-COM)), 
	pool : empty >
	[==> 7 : SOCKET-TYPE-2
	  | some data( SOURCE-COM | EVENT-FRONT-SPEED-LIMIT | TRIP-START | 0 | 1 ) ]  .
    eq test8 = < 8 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('rt-arr-flag -> 0), ('rt-comm -> null)), 
	pool : empty >
	[==> 8 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-REAL-TIME-INFO | 9 | 0 | 1 ) ]  .
    eq test9 = < 9 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('rt-arr-flag -> 0), ('rt-comm -> null)), 
	pool : pool1 >
	[==> 9 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-CLOCK-SYNC | 9 | 0 | 1 ) ]  .   

    --- rl [schedule] :
    --- assume this transition is instantaneous
    eq < O : Core | cpu : ideal, pool : (T ; P) > = < O : Core | cpu : T, pool : P > .

    --- wait to read msgs, if existing, then read
    crl [core-socket-rcv-n-read-some] :
	< O : Core | cpu : T, pool : P >
      	[==> O : S | some F ]
      => < O : Core | cpu : ideal, pool : enqueue(T', P) >
	[==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T
	  /\ T' := < socket-rcv(S) : Thread | st : core-frame-parse(F) > .

    --- wait to read msgs, if not exisiting, then switch
    crl [core-socket-rcv-n-read-none] :
	< O : Core | cpu : T, pool : P > [==> O : S | none ]
      => < O : Core | cpu : ideal, pool : enqueue(T, P) > [==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T .

    --- parse frames, including commands and data
    eq core-frame-parse(command(C)) = threadpool-add(command-frame-rcv-handle, C) .
    eq core-frame-parse(data(D)) = core-data-frame-rcv-handle(D) .

    op core-handle : Command -> Status .

    --- create a new thread in pool to handle commands, then return to while loop reading
    crl [core-threadpool-add-command] :
	< O : Core | cpu : T, pool : P >
      => < O : Core | cpu : ideal, pool : enqueue(T', enqueue(NEW, P)) >
      if < socket-rcv(S) : Thread | st : threadpool-add(command-frame-rcv-handle, C) > := T
	  /\ T' := < socket-rcv(S) : Thread | st : read >
	  /\ NEW := < command-frame-rcv-handle : Thread | st : core-handle(C) > . 

    op limit-data-rcv-handle : Value -> Status .
    op realtime-data-rcv-handle : Value -> Status .

    --- data_frame_rcv_handle
    eq core-data-frame-rcv-handle( SOURCE-COM | EVENT-FRONT-SPEED-LIMIT | V | AMOUNT | CNT )
      = limit-data-rcv-handle(V) .
    eq core-data-frame-rcv-handle( SOURCE-COM | EVENT-REAL-TIME-INFO | V | AMOUNT | CNT )
      = realtime-data-rcv-handle(V) .
    eq core-data-frame-rcv-handle( S:EventSource | E:EventType | V | AMOUNT | CNT )
      = done [owise] .
    *** DONE for CORE
        
    --- behavior of limit_data_rcv_handle( ) in data_frame_rcv_handle
    eq limit-data-rcv-handle(V) = done .

    --- behavior of realtime_data_rcv_handle( ) in data_frame_rcv_handle
    crl [core-realtime-data-rcv-handle] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['rt-comm := V]['rt-arr-flag := 1],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : realtime-data-rcv-handle(V) > := T
	  /\ T' := < socket-rcv(S) : Thread | st : done > . 

    --- definition of "done" status of the thread socekt_rcv():
    --- back to loop reading
    eq < socket-rcv(S) : Thread | st : done >
      = < socket-rcv(S) : Thread | st : read > .
    
    op set-commu-addr : Oid -> Status .
    op set-sys-status : SystemStatus -> Status .
    op set-trip-status : TripStatus -> Status .
      
    --- command_frame_rcv_handle
    eq core-handle( SOURCE-VOTE | EVENT-BROADCAST-COM-ADDR | V )
      = if V == SOURCE-COM then set-commu-addr(COM-DES) 
        else done fi .
    eq core-handle( SOURCE-VOTE | EVENT-MASTER-VOTE-EXCHANGE | V )
      = set-sys-status(V) .
    eq core-handle( SOURCE-VOTE | EVENT-SYS-TRIP-STATUS-SEND | V ) 
      = set-trip-status(V) .
    eq core-handle( S:EventSource | E:EventType | V ) = done [owise] .
    *** DONE for CORE 

    --- behavior of set_commu_addr( ) in command_frame_rcv_handle
    crl [core-set-commu-addr] :
	< O : Core | cpu : T, mem : M, pool : P >
      => if O' == COM-DES 
	 then < O : Core | cpu : ideal, mem : M['master-commu-addr := O'], pool : enqueue(T', P) >
	 else < O : Core | cpu : ideal, mem : M, pool : enqueue(T', P) > fi
      if < command-frame-rcv-handle : Thread | st : set-commu-addr(O') > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : done > . 

    --- behavior of set_sys_status( ) in command_frame_rcv_handle
    crl [core-set-sys-status] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['sys-status := SYSST], pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-sys-status(SYSST) > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : done > . 

    --- behavior of set_trip_status( ) in command_frame_rcv_handle
    crl [core-set-trip-status] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['trip-status := TRIPST], pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-trip-status(TRIPST) > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : done > . 

    --- thread command_frame_rcv_handle done
    crl [core-command-frame-rcv-handle-done] :
	< O : Core | cpu : T > => < O : Core | cpu : ideal >
      if < command-frame-rcv-handle : Thread | st : done > := T .

    ***********************************
    *** behavior of thread rt-main
    ***********************************

    op wait : -> Status .
    op rt-processing : -> Status .
    op rt-send : -> Status .

    --- rt-process: do the optimization
    --- assumed to return the input value, i.e., do nothing
    op rt-process : Value -> Value .
    eq rt-process(V) = V .
      
    --- rt-main always waits for the realtime data
    crl [core-rt-main-wait-some] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['rt-arr-flag := 0]['rt-in := M['rt-comm]],
		      pool : enqueue(T', P) >
      if < rt-main : Thread | st : wait > := T
	  /\ M['rt-arr-flag] == 1
	  /\ T' := < rt-main : Thread | st : rt-processing > .
    crl [core-rt-main-wait-none] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, pool : enqueue(T, P) >
      if < rt-main : Thread | st : wait > := T
	  /\ M['rt-arr-flag] == 0 .

    --- behavior of rt-process in rt-main
    crl [core-rt-main-processing] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['rt-core := rt-process(M['rt-in])],
		      pool : enqueue(T', P) >
      if < rt-main : Thread | st : rt-processing > := T
	  /\ T' := < rt-main : Thread | st : rt-send > .

    --- behavior of frame_encap (sending the processed result) in rt-main
    crl [core-rt-main-send-succ] :
	< O : Core | cpu : T, mem : M, pool : P > [==> VOTE-DES : SOCKET-TYPE-1 | none]
      => < O : Core | cpu : ideal, pool : enqueue(T', P) >
         [==> VOTE-DES : SOCKET-TYPE-1
	      | some data( SOURCE-CORE | EVENT-REAL-TIME-CTRL | M['rt-core] | 0 | 0 )]
      if < rt-main : Thread | st : rt-send > := T
	  /\ T' := < rt-main : Thread | st : wait > .    
    crl [core-rt-main-send-block] :
	< O : Core | cpu : T, mem : M, pool : P > [==> VOTE-DES : SOCKET-TYPE-1 | some F]
      => < O : Core | cpu : ideal, pool : enqueue(T, P) >
         [==> VOTE-DES : SOCKET-TYPE-1 | some F]
      if < rt-main : Thread | st : rt-send > := T .

    ops test10 test11 : -> Configuration .
    op test : Nat -> Configuration .
    eq test10 = < 10 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 0), ('rt-arr-flag -> 1)), 
	pool : pool1 >
	[==> 10 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-CLOCK-SYNC | 9 | 0 | 1 ) ] .   
    eq test11 = < 10 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 0), ('rt-arr-flag -> 0)), 
	pool : pool1 >
	[==> 10 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-CLOCK-SYNC | 9 | 0 | 1 ) ] .
    eq test(12) = < 12 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 0), ('rt-arr-flag -> 1)), 
	pool : empty >
	[==> 10 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-CLOCK-SYNC | 9 | 0 | 1 ) ] .
    eq test(13) = < 13 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 9), ('rt-arr-flag -> 1)), 
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none] .
    eq test(14) = < 14 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 9), ('rt-arr-flag -> 1)), 
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | some ftest ] . 

endom)

    
(omod VOTE is
    protecting TO-STATUS .
    protecting BOARD .
    protecting SOCKET .
    protecting RT-VOTE .
    protecting RT-CORE .
    protecting THROTTLE-GEAR .
    protecting VALUE .

    class Vote .
    subclass Vote < Board .

    --- threads
    op socket-rcv : SocketType -> ThreadID [ctor] .
    op command-frame-rcv-handle : -> ThreadID .
    
    op read : -> Status .
    op vote-frame-parse : Frame -> Status .
    op threadpool-add : ThreadID Command -> Status .
    op vote-data-frame-rcv-handle : Data -> Status .
    op done : -> Status .
    op _;_ : Status Status -> Status [ctor assoc id: done] .

    
    vars O O' : Oid .
    var S : SocketType .
    vars N N' : Nat .
    var M : Memory .
    vars T T' : Object .
    var P : ThreadPool .
    var F : Frame .
    subsort Nat < Oid .
    var OB : Object .
    var C : Command .
    var NEW : Object .
    var CON : Configuration .
    vars D DATA : Data .
    var V : Value .
    var SYSST : SystemStatus .
    var TRIPST : TripStatus .
    vars AMOUNT CNT : Nat .
    vars ST ST' ST'' : Status .
    
    op msg1 : Oid Nat -> Msg .
    op cpu1 : -> Object .
    op mem1 : -> Memory .
    op pool1 : -> ThreadPool .
    op ftest : -> Frame .
    op com1 : -> Command .
    op data1 : -> Data .
    ops a b c : -> Object .

    --- scheduling strategy
    --- assume this transition is instantaneous
    eq < O : Vote | cpu : ideal, pool : (T ; P) > = < O : Vote | cpu : T, pool : P > .
    
    **********************************
    *** behavior of socket-rcv
    *********************************
    
    --- wait to read msgs, if existing, then read
    crl [vote-socket-rcv-n-read-some] :
	< O : Vote | cpu : T, pool : P >
      	[==> O : S | some F ]
      => < O : Vote | cpu : ideal, pool : enqueue(T', P) >
	[==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T
	  /\ T' := < socket-rcv(S) : Thread | st : vote-frame-parse(F) > .

    --- wait to read msgs, if not exisiting, then switch
    crl [vote-socket-rcv-n-read-none] :
	< O : Vote | cpu : T, pool : P > [==> O : S | none ]
      => < O : Vote | cpu : ideal, pool : enqueue(T, P) > [==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T .

    --- parse frames, including commands and data
    eq vote-frame-parse(command(C)) = threadpool-add(command-frame-rcv-handle, C) .
    eq vote-frame-parse(data(D)) = vote-data-frame-rcv-handle(D) .

    op vote-handle : Command -> Status .

    --- create a new thread in pool to handle commands, then return to while loop reading
    crl [vote-threadpool-add-command] :
	< O : Vote | cpu : T, pool : P >
      => < O : Vote | cpu : ideal, pool : enqueue(T', enqueue(NEW, P)) >
      if < socket-rcv(S) : Thread | st : threadpool-add(command-frame-rcv-handle, C) > := T
	  /\ T' := < socket-rcv(S) : Thread | st : read >
	  /\ NEW := < command-frame-rcv-handle : Thread | st : vote-handle(C) > .

    **********************************
    *** behavior of data-frame-rcv-handle
    **********************************

    --- the end of function data-frame-rcv-handle: "done"
    --- definition of "done" status of the thread socekt_rcv():
    --- back to loop reading
    eq < socket-rcv(S) : Thread | st : done >
      = < socket-rcv(S) : Thread | st : read > .

    op set-branch-status : Nat -> Status .
    op set-branch-info : Value -> Status .
    op set-side-status : Nat -> Status .
    op set-side-info : Value -> Status .
    op ctrbox-data : EventType -> Status .
    op handle-event-front-side-line-pass : Value -> Status .
    op rt-handle : Value -> Status .

    --- data_frame_rcv_handle
    eq vote-data-frame-rcv-handle( SOURCE-COM | EVENT-FRONT-BRANCH-TRANSFER | V | AMOUNT | CNT )
      = set-branch-status(1) ; set-branch-info(V) ; done .
    eq vote-data-frame-rcv-handle( SOURCE-COM | EVENT-FRONT-SIDE-LINE-PASS | V | AMOUNT | CNT )
      = handle-event-front-side-line-pass(V) .
    eq vote-data-frame-rcv-handle( SOURCE-CORE | EVENT-REAL-TIME-CTRL | V | AMOUNT | CNT )
      = rt-handle(V) .
    eq vote-data-frame-rcv-handle( S:EventSource | E:EventType | V | AMOUNT | CNT )
      = done [owise] .
    *** DONE for VOTE
    

    --- behavior of set_branch_status( ) in data_frame_rcv_handle
    crl [vote-set-branch-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['branch-status := 1],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : set-branch-status(1) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .

    --- behavior of set_branch_info( ) in data_frame_rcv_handle
    crl [vote-set-branch-info] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['branch-info := V],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : set-branch-info(V) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .    

    --- behavior/definition of handle-event-front-side-line-pass
    ceq < O : Vote | cpu : < socket-rcv(S) : Thread | st : ST >, mem : M >
      = if M['side-status] =/= 0
	then < O : Vote | cpu : < socket-rcv(S) : Thread | st : done > >
	else < O : Vote | cpu : < socket-rcv(S) : Thread | st : ST' > >
        fi
      if handle-event-front-side-line-pass(V) := ST
	  /\ ST' := set-side-status(1) ; set-side-info(V) ;
      	            ctrbox-data(EVENT-FRONT-SIDE-LINE-PASS) ; done .
      
    --- behavior of set_side_status( ) in data_frame_rcv_handle
    crl [vote-set-side-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['side-status := 1],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : set-side-status(1) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .

    --- behavior of set_side_info( ) in data_frame_rcv_handle
    crl [vote-set-side-info] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['side-info := V],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : set-side-info(V) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .

    op send-side-info-to-ctrbox : -> Status .
      
    --- the function ctrbox-data defined in ctrbox_comm.c
    eq ctrbox-data(EVENT-FRONT-SIDE-LINE-PASS) = send-side-info-to-ctrbox ; done .

    
    --- behavior of send-side-info-to-ctrbox generated by
    --- function ctrbox-data in data_frame_rcv_handle
    crl [vote-send-side-info-to-ctrbox-succ] :
	< O : Vote | cpu : T, mem : M, pool : P > [==> CON-DES : SOCKET-TYPE-5 | none]
      => < O : Vote | cpu : ideal, pool : enqueue(T', P) >
	[==> CON-DES : DAT-SOC | some data(DATA)]
      if < socket-rcv(S) : Thread | st : send-side-info-to-ctrbox ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > 
	  /\ DATA := SOURCE-VOTE | EVENT-VOTE-SIDE-LINE-PASS-START | M['side-info] | 0 | 0 .
    crl [vote-send-side-info-to-ctrbox-block] :
	< O : Vote | cpu : T, mem : M, pool : P > [==> CON-DES : SOCKET-TYPE-5 | some F]
      => < O : Vote | cpu : ideal, pool : enqueue(T, P) >
	[==> CON-DES : DAT-SOC | some F]
      if < socket-rcv(S) : Thread | st : send-side-info-to-ctrbox ; ST > := T .

      
    --- behavior of rt_handle( ) in data_frame_rcv_handle, and located in rt_handle.c
    crl [vote-rt-handle] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal,
		      mem : M['rt-vote := (rt-core: V , rt-control-status: CONTROL-AUTO )],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : rt-handle(V) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .      

      
    **********************************
    *** behavior of command-frame-rcv-handle
    **********************************

    --- thread command_frame_rcv_handle done
    crl [vote-command-frame-rcv-handle-done] :
	< O : Vote | cpu : T > => < O : Vote | cpu : ideal >
      if < command-frame-rcv-handle : Thread | st : done > := T .

    op set-auto-ack-status : Nat -> Status .
    op set-manual-ack-status : Nat -> Status .
    op handle-event-mannal-to-auto : -> Status .
    op set-to-manual-status : Nat -> Status .
      
    --- command_frame_rcv_handle
    *** events from SOURCE-COM are all omitted
    *** events from SOURCE-CORE are all omitted
    eq vote-handle( SOURCE-CONTROL | EVENT-GEAR8-AUTO-CONFIRM-ACK | V )
      = set-auto-ack-status(1) .
    eq vote-handle( SOURCE-CONTROL | EVENT-TWO-GEAR-TO-MANNUL | V )
      = set-manual-ack-status(1) .
    eq vote-handle( SOURCE-CONTROL | EVENT-MANNAL-TO-AUTO | V )
      = handle-event-mannal-to-auto .
    eq vote-handle( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | V )
      = set-to-manual-status(1) .
    eq vote-handle( S:EventSource | E:EventType | V ) = done [owise] .
    *** DONE for VOTE
    

    --- behavior of set_auto_ack_status( ) in command_frame_rcv_handle
    crl [vote-set-auto-ack-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['auto-ack-status := 1],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-auto-ack-status(1) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .

    --- behavior of set_manual_ack_status( ) in command_frame_rcv_handle
    crl [vote-set-manual-ack-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['manual-ack-status := 1],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-manual-ack-status(1) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .      

    op set-to-auto-gear : Nat -> Status .
    op get-throttle : Memory -> Nat .
    op set-to-auto-status : Nat -> Status .
      
    --- behavior/definition of handle-event-mannal-to-auto in command_frame_rcv_handle
    --- crl [vote-handle-event-mannal-to-auto] :
    ceq < O : Vote | cpu : < command-frame-rcv-handle : Thread | st : ST >,
		     mem : M >
      = < O : Vote | cpu : < command-frame-rcv-handle : Thread | st : ST' > >
      if handle-event-mannal-to-auto := ST
	  /\ ST' := set-to-auto-gear(get-throttle(M)) ; set-to-auto-status(1) .

    eq get-throttle(M) = (M['throttle-gear1]).gear .

    --- behavior of set_to_auto_gear( ) in command_frame_rcv_handle
    crl [vote-set-to-auto-gear] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['to-auto-gear := N],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-to-auto-gear(N) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .

    --- behavior of set_to_auto_status( ) in command_frame_rcv_handle
    crl [vote-set-to-auto-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['to-auto-status := 1],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-to-auto-status(1) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .

    --- behavior of set_to_manual_status( ) in command_frame_rcv_handle
    crl [vote-set-to-manual-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['to-manual-status := 1],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-to-manual-status(1) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .                  

      
    *********************************
    *** Testing
    *********************************
    
    op test : Nat -> Configuration .
    eq test(15) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : empty, pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-FRONT-BRANCH-TRANSFER | 33 | 0 | 0 ) ] .
    eq test(16) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 1), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-FRONT-SIDE-LINE-PASS | 33 | 0 | 0 ) ]
	[==> CON-DES : DAT-SOC | none ] .
    eq test(17) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-FRONT-SIDE-LINE-PASS | 33 | 0 | 0 ) ]
	[==> CON-DES : DAT-SOC | none ] .
    eq test(18) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-FRONT-SIDE-LINE-PASS | 33 | 0 | 0 ) ]
	[==> CON-DES : DAT-SOC
	  | some data( SOURCE-COM | EVENT-FRONT-BRANCH-TRANSFER | 33 | 0 | 0 ) ] .
    eq test(19) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-CORE | EVENT-REAL-TIME-CTRL | 99 | 0 | 0 ) ]
	[==> CON-DES : DAT-SOC | none ] .
    eq test(20) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-GEAR8-AUTO-CONFIRM-ACK | 1 ) ] .
    eq test(21) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-TWO-GEAR-TO-MANNUL | 1 ) ] .
    eq test(22) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : (('side-status -> 0), ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 ))),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-MANNAL-TO-AUTO | 1 ) ] .
    eq test(23) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : (('side-status -> 0), ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 ))),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .
      

    *********************************
    *** Behavior of thread fsm_run
    *********************************
    
    op fsm-run : -> ThreadID [ctor] .
    op while-fsm-start : -> Status .

    op set-fsm-rt : -> Status .
    op compute-auto-status : -> Status .
    op compute-branch-status : -> Status .
    op compute-side-status : -> Status .
    op compute-to-manual-status : -> Status .
    op fsm-control : -> Status .
    op rtvote-diff : -> Status .

    --- the end of thread fsm_run: "done"
    --- definition of "done" status of the thread fsm_run:
    --- back to while loop 
    eq < fsm-run : Thread | st : done >
      = < fsm-run : Thread | st : while-fsm-start > .

    --- behavior/definition of while-fsm-start in fsm_run
    ceq < O : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
		     mem : M >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST' > >
      if ST' := set-fsm-rt ; compute-auto-status ; compute-branch-status ;
	  compute-side-status ; compute-to-manual-status ; fsm-control ; 
	  rtvote-diff ; done .

    --- behavior of set-fsm-rt in fsm_run
    crl [vote-set-fsm-rt] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['fsm-rt := M['rt-vote]],
		      pool : enqueue(T', P) >
      if < fsm-run : Thread | st : set-fsm-rt ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .                        


    --- definition of function can_manual_to_auto
    --- simply assume it is primitive
    op can-manual-to-auto : Memory -> Bool .
    op pred-rt-core : Memory -> Bool . --- a predicate on rt_core.
    ceq can-manual-to-auto(M) = false
      if M['branch-status] == 1 /\ (M['branch-pos]) >= 2 .
    ceq can-manual-to-auto(M) = false
      if M['side-status] == 1 /\ ((M['side-pos]) == 2 or (M['side-pos]) == 3) .
    eq can-manual-to-auto(M)
      = if pred-rt-core(M) then true else false fi [owise] .

    --- definition of pred-rt-core
    --- incomplete wrt the code
    eq pred-rt-core(M) = (((M['fsm-rt]).rt-core).rt-enable-status == 1) .

    --- behavior of compute-auto-status in fsm_run
    crl [vote-compute-auto-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if can-manual-to-auto(M)
	then < O : Vote | cpu : ideal, mem : M['auto-status := 1],
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M['auto-status := 0],
			  pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : compute-auto-status ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .                        

    --- behavior of compute-branch-status in fsm_run
    crl [vote-compute-branch-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if M['branch-status] == 1 and M['branch-pos] == 3
	then < O : Vote | cpu : ideal, mem : M['branch-status := 0],
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M,
			  pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : compute-branch-status ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .                        

    --- behavior of compute-side-status in fsm_run
    crl [vote-compute-side-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if M['side-status] == 1 and M['side-pos] == 4
	then < O : Vote | cpu : ideal, mem : M['side-status := 0],
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M,
			  pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : compute-side-status ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    --- behavior of compute-to-manual-status in fsm_run
    crl [vote-compute-to-manual-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if M['auto-status] == 1
	then < O : Vote | cpu : ideal, mem : (M).fsm-set-enable(1),
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : (M['to-manual-status := 1]).fsm-set-enable(0),
			  pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : compute-to-manual-status ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    op case-fsm-manual : -> Status .
    op case-fsm-start-auto : -> Status .
    op case-fsm-ack-auto : -> Status .
    op case-fsm-over-time-compare-gear : -> Status .
    op case-fsm-over-time-compare-throttle : -> Status .
    op case-fsm-auto-compare-throttle : -> Status .
    op case-fsm-auto-to-manual : -> Status .
    op case-fsm-start-manual : -> Status .
    op case-fsm-ack-manual : -> Status .
      
    --- behavior/definition of fsm-control in fsm_run
    ceq < O : Vote | cpu : < fsm-run : Thread | st : fsm-control ; ST >,
		     mem : M >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST' ; ST > >
      if M['fsm-state] == FSM-MANUAL /\ ST' := case-fsm-manual .
    ceq < O : Vote | cpu : < fsm-run : Thread | st : fsm-control ; ST >,
		     mem : M >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST' ; ST > >
      if M['fsm-state] == FSM-START-AUTO /\ ST' := case-fsm-start-auto .    
    ceq < O : Vote | cpu : < fsm-run : Thread | st : fsm-control ; ST >,
		     mem : M >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST' ; ST > >
      if M['fsm-state] == FSM-ACK-AUTO /\ ST' := case-fsm-ack-auto .    
    ceq < O : Vote | cpu : < fsm-run : Thread | st : fsm-control ; ST >,
		     mem : M >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST' ; ST > >
      if M['fsm-state] == FSM-OVER-TIME 
	  /\ ST' := case-fsm-over-time-compare-gear ; case-fsm-over-time-compare-throttle .    
    ceq < O : Vote | cpu : < fsm-run : Thread | st : fsm-control ; ST >,
		     mem : M >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST' ; ST > >
      if M['fsm-state] == FSM-AUTO 
	  /\ ST' := case-fsm-auto-compare-throttle ; case-fsm-auto-to-manual .    
    ceq < O : Vote | cpu : < fsm-run : Thread | st : fsm-control ; ST >,
		     mem : M >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST' ; ST > >
      if M['fsm-state] == FSM-START-MANUAL /\ ST' := case-fsm-start-manual .
    ceq < O : Vote | cpu : < fsm-run : Thread | st : fsm-control ; ST >,
		     mem : M >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST' ; ST > >
      if M['fsm-state] == FSM-ACK-MANUAL /\ ST' := case-fsm-ack-manual .

    

    op _.fsm-set-gear`(_`) : Memory Nat -> Memory .
    eq (M).fsm-set-gear(N) = M['fsm-rt := 
	  (rt-core: (rt-gear: N ,rt-enable-status: ((M['fsm-rt]).rt-core).rt-enable-status )
	    ,rt-control-status: (M['fsm-rt]).rt-control-status ) ] .

    op _.fsm-set-enable`(_`) : Memory Nat -> Memory .
    eq (M).fsm-set-enable(N) = M['fsm-rt := 
	  (rt-core: (rt-gear: ((M['fsm-rt]).rt-core).rt-gear ,rt-enable-status: N )
	    ,rt-control-status: (M['fsm-rt]).rt-control-status ) ] .    
    
    var CS : ControlStatus .
    
    op _.fsm-set-control`(_`) : Memory ControlStatus -> Memory .
    eq (M).fsm-set-control(CS) = M['fsm-rt := 
	  (rt-core: (M['fsm-rt]).rt-core ,rt-control-status: CS ) ] .
    
    --- behavior of case-fsm-manual in fsm_run
    crl [vote-case-fsm-manual] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if M['to-auto-status] == 1
	then < O : Vote | cpu : ideal,
                          mem : ((M['fsm-state := FSM-START-AUTO]).fsm-set-gear((M['throttle-gear1]).gear)).fsm-set-control(CONTROL-MANNUL),
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal,
			  mem : ((M).fsm-set-gear((M['throttle-gear1]).gear)).fsm-set-control(CONTROL-MANNUL),
			  pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : case-fsm-manual ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    op _.status-init : Memory -> Memory .
    eq (M).status-init
      = M['to-auto-status := 0]['to-manual-status := 0]['auto-ack-status := 0]['manual-ack-status := 0] .
      
    --- behavior of case-fsm-start-auto in fsm_run
    crl [vote-case-fsm-start-auto-timeout] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['fsm-state := FSM-OVER-TIME], 
		      pool : enqueue(T', P) >
      if < fsm-run : Thread | st : case-fsm-start-auto ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .
    crl [vote-case-fsm-start-auto] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if M['to-auto-gear] == 8
	then < O : Vote | cpu : ideal,
                          mem : M['fsm-state := FSM-ACK-AUTO],
			  pool : enqueue(T', P) > 
	else (if (M['throttle-gear1]).gear == 8
      	      then < O : Vote | cpu : ideal,
		   	        mem : (M['fsm-state := FSM-AUTO]).status-init,
			        pool : enqueue(T', P) >
	      else < O : Vote | cpu : ideal, mem : M, pool : enqueue(T', P) >
	      fi)
	fi
      if < fsm-run : Thread | st : case-fsm-start-auto ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    --- behavior of case-fsm-ack-auto in fsm_run
    crl [vote-case-fsm-ack-auto-timeout] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['fsm-state := FSM-OVER-TIME], 
		      pool : enqueue(T', P) >
      if < fsm-run : Thread | st : case-fsm-ack-auto ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > . 
    crl [vote-case-fsm-ack-auto] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if M['auto-ack-status] == 1
	then < O : Vote | cpu : ideal,
                          mem : (M['fsm-state := FSM-AUTO]).status-init,
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M, pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : case-fsm-ack-auto ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    --- behavior of case-fsm-over-time-compare-gear in fsm_run
    crl [vote-case-fsm-over-time-compare-gear] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if ((M['fsm-rt]).rt-core).rt-gear > 0
	then < O : Vote | cpu : ideal,
                          mem : (M).fsm-set-gear(0),
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M, pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : case-fsm-over-time-compare-gear ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    --- behavior of case-fsm-over-time-compare-throttle in fsm_run
    crl [vote-case-fsm-over-time-compare-throttle] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if (M['throttle-gear1]).gear <= ((M['fsm-rt]).rt-core).rt-gear
	then < O : Vote | cpu : ideal,
                          mem : (M['fsm-state := FSM-MANUAL]).status-init,
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M, pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : case-fsm-over-time-compare-throttle ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    --- behavior of case-fsm-auto-compare-throttle in fsm_run
    crl [vote-case-fsm-auto-compare-throttle] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if (M['throttle-gear1]).gear =/= 8
	then < O : Vote | cpu : ideal,
                          mem : M['to-manual-status := 1],
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M, pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : case-fsm-auto-compare-throttle ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    --- behavior of case-fsm-auto-to-manual in fsm_run
    crl [vote-case-fsm-auto-to-manual] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if M['to-manual-status] == 1
	then < O : Vote | cpu : ideal,
                          mem : M['fsm-state := FSM-START-MANUAL],
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M, pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : case-fsm-auto-to-manual ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    --- behavior of case-fsm-start-manual in fsm_run
    crl [vote-case-fsm-start-manual-timeout] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['fsm-state := FSM-OVER-TIME], 
		      pool : enqueue(T', P) >
      if < fsm-run : Thread | st : case-fsm-start-manual ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > . 
    crl [vote-case-fsm-start-manual] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if (M['throttle-gear1]).gear <= ((M['fsm-rt]).rt-core).rt-gear
	then < O : Vote | cpu : ideal,
                          mem : (M['fsm-state := FSM-MANUAL]).status-init,
			  pool : enqueue(T', P) > 
	else (if (M['throttle-gear1]).gear <= 2 + ((M['fsm-rt]).rt-core).rt-gear
      	      then < O : Vote | cpu : ideal,
		   	        mem : M['fsm-state := FSM-ACK-MANUAL],
			        pool : enqueue(T', P) >
	      else < O : Vote | cpu : ideal, mem : M, pool : enqueue(T', P) >
	      fi)
	fi
      if < fsm-run : Thread | st : case-fsm-start-manual ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .

    --- behavior of case-fsm-ack-manual in fsm_run
    crl [vote-case-fsm-ack-manual-timeout] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['fsm-state := FSM-OVER-TIME], 
		      pool : enqueue(T', P) >
      if < fsm-run : Thread | st : case-fsm-ack-manual ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > . 
    crl [vote-case-fsm-ack-manual] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => if M['manual-ack-status] == 1
	then < O : Vote | cpu : ideal,
                          mem : (M['fsm-state := FSM-MANUAL]).status-init,
			  pool : enqueue(T', P) > 
	else < O : Vote | cpu : ideal, mem : M, pool : enqueue(T', P) >
	fi
      if < fsm-run : Thread | st : case-fsm-ack-manual ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > . 


    op send-throttle : Nat ControlStatus -> Status .
    op set-fsm-temp : -> Status .

    --- behavior/definition of rtvote-diff in fsm_run
    ceq < O : Vote | cpu : < fsm-run : Thread | st : rtvote-diff ; ST >,
		     mem : M >
      = if (M['fsm-rt]).rt-control-status =/= (M['fsm-temp]).rt-control-status
        then < O : Vote | cpu : < fsm-run : Thread | st : ST' ; set-fsm-temp ; ST > >
	else (if (M['fsm-rt]).rt-control-status == CONTROL-AUTO
                 and ((M['fsm-rt]).rt-core).rt-gear =/= ((M['fsm-temp]).rt-core).rt-gear 
              then < O : Vote | cpu : < fsm-run : Thread | st : ST' ; set-fsm-temp ; ST > >
	      else < O : Vote | cpu : < fsm-run : Thread | st : set-fsm-temp ; ST > > 
	      fi)
	fi
      if M['fsm-rt] =/= M['fsm-temp] 
	 /\ ST' := send-throttle(((M['fsm-rt]).rt-core).rt-gear , 
		                 (M['fsm-rt]).rt-control-status) .
    eq < O : Vote | cpu : < fsm-run : Thread | st : rtvote-diff ; ST > >
      = < O : Vote | cpu : < fsm-run : Thread | st : ST > > [owise] .

    --- behavior of send-throttle in fsm_run
    crl [vote-send-throttle-0-succ] :
	< O : Vote | cpu : T, mem : M, pool : P > [==> OUT-DES : PORT-CANINOUT | none]
      => < O : Vote | cpu : ideal, pool : enqueue(T', P) >
	[==> OUT-DES : PORT-CANINOUT | some (gear: N ,auto-or-manual: 0) ]
      if < fsm-run : Thread | st : send-throttle(N , CONTROL-MANNUL) ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .
    crl [vote-send-throttle-1-succ] :
	< O : Vote | cpu : T, mem : M, pool : P > [==> OUT-DES : PORT-CANINOUT | none]
      => < O : Vote | cpu : ideal, pool : enqueue(T', P) >
	[==> OUT-DES : PORT-CANINOUT | some (gear: N ,auto-or-manual: 1) ]
      if < fsm-run : Thread | st : send-throttle(N , CONTROL-AUTO) ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > .
    crl [vote-send-throttle-block] :
	< O : Vote | cpu : T, mem : M, pool : P > [==> OUT-DES : PORT-CANINOUT | some F]
      => < O : Vote | cpu : ideal, pool : enqueue(T, P) >
	[==> OUT-DES : PORT-CANINOUT | some F]
      if < fsm-run : Thread | st : send-throttle(N , CS) ; ST > := T . 

    --- behavior of set-fsm-temp in fsm_run
    crl [vote-set-fsm-temp] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal,
                      mem : M['fsm-temp := M['fsm-rt]],
 	              pool : enqueue(T', P) > 
      if < fsm-run : Thread | st : set-fsm-temp ; ST > := T
	  /\ T' := < fsm-run : Thread | st : ST > . 

    
    *********************************
    *** Testing
    *********************************

    eq test(24) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 0), ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	       ('rt-vote -> (rt-core: 123 ,rt-control-status: CONTROL-AUTO ))),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .
    eq test(25) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 0), ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('rt-vote -> (rt-core: 123 ,rt-control-status: CONTROL-AUTO )),
	('side-pos -> 3)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .
    eq test(26) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1), ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('rt-vote -> (rt-core: 123 ,rt-control-status: CONTROL-AUTO )),
	('side-pos -> 2)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .
    eq test(27) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: 123 ,rt-control-status: CONTROL-AUTO )),
	    ('side-pos -> 2), ('branch-status -> 1), ('branch-pos -> 2)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .
    eq test(28) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: 123 ,rt-control-status: CONTROL-AUTO )),
	    ('side-pos -> 2), ('branch-status -> 1), ('branch-pos -> 3)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .
    eq test(29) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: 123 ,rt-control-status: CONTROL-AUTO )),
	    ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .     
    eq test(30) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 8 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL),
	  ('throttle-gear1 -> (gear: 6 ,auto-or-manual: 0 ))),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .
    eq test(31) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 8 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 6 ,auto-or-manual: 0 ))),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .         
    eq test(32) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 8 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 6 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(33) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 8 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 6 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 7)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(34) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 8 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 7)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(35) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 8 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 7 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(36) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 8 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 7 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('auto-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(37) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 8 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 7 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('auto-ack-status -> 0)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(38) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 0 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 7 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('auto-ack-status -> 0)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(39) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 6 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 0 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('auto-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(40) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 6 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-START-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 0 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('auto-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(41) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 6 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-START-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 7 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('auto-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(42) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-START-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('auto-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(43) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-ACK-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('auto-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(44) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-ACK-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(45) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-AUTO), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(46) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(47) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-OVER-TIME), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none ] .         
    eq test(48) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-OVER-TIME), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : empty >
	[==> OUT-DES : PORT-CANINOUT | none ] .         
    eq test(49) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : empty >
	[==> OUT-DES : PORT-CANINOUT | none ] .         
    eq test(50) = < VOTE-DES : Vote | cpu : < fsm-run : Thread | st : while-fsm-start >,
	mem : (('side-status -> 1),
	  ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1) ,rt-control-status: CONTROL-AUTO )),
	  ('side-pos -> 4), ('branch-status -> 1), ('branch-pos -> 3),
	  ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : empty >
	[==> OUT-DES : PORT-CANINOUT | some (gear: 0 ,auto-or-manual: 0) ] .         


    ************************************
    *** behavior of thread receive_throttle
    *** --- in fact the behavior here includes also the thread main
    ************************************

    op receive-throttle : -> ThreadID [ctor] .
    op receive : -> Status .

    var G : ThrottleGear .
    
    --- behavior of set-fsm-rt in fsm_run
    crl [vote-receive-throttle-some] :
	< O : Vote | cpu : T, mem : M, pool : P >
	[==> O : PORT-CANINOUT | some G ]
      => < O : Vote | cpu : ideal, mem : M['throttle-gear1 := G],
		      pool : enqueue(T', P) >
	 [==> O : PORT-CANINOUT | none ]
      if < receive-throttle : Thread | st : receive > := T
	  /\ T' := < receive-throttle : Thread | st : receive > .
    crl [vote-receive-throttle-none] :
	< O : Vote | cpu : T, pool : P >
	[==> O : PORT-CANINOUT | none ]
      => < O : Vote | cpu : ideal, pool : enqueue(T', P) >
	 [==> O : PORT-CANINOUT | none ]
      if < receive-throttle : Thread | st : receive > := T
	  /\ T' := < receive-throttle : Thread | st : receive > .      

    --- testing
    eq test(51) = < VOTE-DES : Vote | cpu : < receive-throttle : Thread | st : receive >,
	mem : (('side-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : empty >
	[==> VOTE-DES : PORT-CANINOUT | some (gear: 0 ,auto-or-manual: 1) ] .
    eq test(52) = < VOTE-DES : Vote | cpu : < receive-throttle : Thread | st : receive >,
	mem : (('side-status -> 1),
	  ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 )),
	  ('to-auto-gear -> 8), ('manual-ack-status -> 1)),
	pool : pool1 >
	[==> VOTE-DES : PORT-CANINOUT | none ] .         
    
endom)

(fmod VALUE-LIST is
    protecting VALUE .
    sort VList .

    op nil : -> VList [ctor] .
    op _;_ : Value VList -> VList [ctor] .
endfm)
            
(omod LKJ is
    protecting VALUE-LIST .
    protecting SOCKET .
    protecting BOARD .
    class LKJ | data : VList .

    var O : Oid .
    var V : Value .
    var L : VList .

    op lkj : -> Oid [ctor] .
    
    --- send out realtime data
    rl [ljk-realtime-data] :
	< O : LKJ | data : V ; L > [==> COM-DES : PORT-LKJ | none ]
      => < O : LKJ | data : L > [==> COM-DES : PORT-LKJ | some V ] .
endom)

(fmod EVENT-LIST is
    protecting TO-STATUS .
    sort EList .

    op nil : -> EList [ctor] .
    op _;_ : EventType EList -> EList [ctor] .
endfm)
    
(omod CTRL-BOX is
    protecting EVENT-LIST .
    protecting SOCKET .
    protecting BOARD .
    class CtrlBox | controls : EList .

    var O : Oid .
    var E : EventType .
    var L : EList .
    var P : PortType .

    --- send out operations (from the driver)
    rl [control-box-operation] :
	< O : CtrlBox | controls : E ; L >
	[==> VOTE-DES : SOCKET-TYPE-CAN2NET | none ]
      => < O : CtrlBox | controls : L >
	[==> VOTE-DES : SOCKET-TYPE-CAN2NET |
	  some command( SOURCE-CONTROL | E | 1 ) ] .

    --- receive events from VOTE
    rl [control-box-rcv-command] :
	< O : CtrlBox | > [==> CON-DES : P | some (F:Frame) ]
      => < O : CtrlBox | > [==> CON-DES : P | none ] .
endom)

(omod OUTPUT-BOARD is
    protecting THROTTLE-GEAR .
    protecting SOCKET .
    protecting BOARD .
    class OutputBrd | gear : Nat, auto-or-manual : Nat .

    var O : Oid .
    vars N M : Nat .
    
    --- receive the throttle sent by VOTE
    rl [output-throttle-receive] :
	< O : OutputBrd | >
	[==> OUT-DES : PORT-CANINOUT | some (gear: N ,auto-or-manual: M) ]
      => < O : OutputBrd | gear : N, auto-or-manual : M >
	[==> OUT-DES : PORT-CANINOUT | none ] .
endom)
    
(tomod SYSTEM is
    protecting SOCKET .
    protecting COMM .
    protecting CORE .
    protecting VOTE .
    protecting LKJ .
    protecting CTRL-BOX .
    protecting THREADPOOL .
    protecting OUTPUT-BOARD . 

    op mem : -> Memory .
    op pool : -> ThreadPool .
    op sys-full : -> Configuration .
    op sys : Nat -> Configuration .    

    eq sys-full =
	< lkj : LKJ | data : 13 ; 24 ; nil >
	< COM-DES : Comm | cpu : ideal, mem : empty, pool :
			   < socket-rcv(SOCKET-TYPE-0) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-1) : Thread | st : read > ;
  	                   < socket-rcv(SOCKET-TYPE-2) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-3) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-4) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-5) : Thread | st : read > ;
	                   < net-thread : Thread | st : read > ; empty >
	< CORE-DES : Core | cpu : ideal, mem : ('rt-arr-flag -> 0), pool :
			   < socket-rcv(SOCKET-TYPE-0) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-1) : Thread | st : read > ;
  	                   < socket-rcv(SOCKET-TYPE-2) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-3) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-4) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-5) : Thread | st : read > ;
	                   < rt-main : Thread | st : wait > ; empty >
	< VOTE-DES : Vote | cpu : ideal,
			    mem : (('throttle-gear1 -> (gear: 7 ,auto-or-manual: 1)),
			      ('side-status -> 0), ('branch-status -> 0),
			      ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 0),
			      ('to-manual-status -> 0), ('auto-ack-status -> 0),
			      ('manual-ack-status -> 0), ('auto-status -> 0),
			      ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-MANNUL )),
			      ('fsm-rt -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-MANNUL )),
			      ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-MANNUL )) ),
			    pool :
			   < socket-rcv(SOCKET-TYPE-0) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-1) : Thread | st : read > ;
  	                   < socket-rcv(SOCKET-TYPE-2) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-3) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-4) : Thread | st : read > ;
	                   < socket-rcv(SOCKET-TYPE-5) : Thread | st : read > ;    
	                   < socket-rcv(SOCKET-TYPE-CAN2NET) : Thread | st : read > ;
                           < receive-throttle : Thread | st : receive > ;
                           < fsm-run : Thread | st : while-fsm-start > ; empty > 
	< CON-DES : CtrlBox | controls : nil >
	< OUT-DES : OutputBrd | gear : 0, auto-or-manual : 0 >
	[==> COM-DES : PORT-LKJ | none ] 
	[==> COM-DES : SOCKET-TYPE-0 | none ]
	[==> COM-DES : SOCKET-TYPE-1 | none ]
	[==> COM-DES : SOCKET-TYPE-2 | none ]
	[==> COM-DES : SOCKET-TYPE-3 | none ]
	[==> COM-DES : SOCKET-TYPE-4 | none ]
	[==> COM-DES : SOCKET-TYPE-5 | none ]
	[==> CORE-DES : SOCKET-TYPE-0 | none ]
	[==> CORE-DES : SOCKET-TYPE-1 | none ]
	[==> CORE-DES : SOCKET-TYPE-2 | none ]
	[==> CORE-DES : SOCKET-TYPE-3 | none ]
	[==> CORE-DES : SOCKET-TYPE-4 | none ]
	[==> CORE-DES : SOCKET-TYPE-5 | none ]
	[==> VOTE-DES : SOCKET-TYPE-0 | none ]
	[==> VOTE-DES : SOCKET-TYPE-1 | none ]
	[==> VOTE-DES : SOCKET-TYPE-2 | none ]
	[==> VOTE-DES : SOCKET-TYPE-3 | none ]
	[==> VOTE-DES : SOCKET-TYPE-4 | none ]
	[==> VOTE-DES : SOCKET-TYPE-5 | none ]
	[==> VOTE-DES : SOCKET-TYPE-CAN2NET | none ] 
	[==> VOTE-DES : PORT-CANINOUT | none ]
	[==> CON-DES : SOCKET-TYPE-5 | none ]
	[==> OUT-DES : PORT-CANINOUT | none ] .    

    ***(
    --- the train is controlled by 5 in manual mode in the auto-enable area;
    --- then the driver switch to auto mode;
    --- when changing mode, the train enters in the auto-disable area.
    --- meeting CONFLICT property:
    --- (not isAutoEnable(C:Configuration)) and (not switchToManual(C:Configuration))
    )
    eq sys(1) =
	< lkj : LKJ | data :
		      (rt-gear: 5 ,rt-enable-status: 1) ;
		      (rt-gear: 2 ,rt-enable-status: 0) ;
		      nil >
	< COM-DES : Comm | cpu : ideal, mem : empty, pool :
			   < socket-rcv(SOCKET-TYPE-0) : Thread | st : read > ;
	                   < net-thread : Thread | st : read > ; empty >
	< CORE-DES : Core | cpu : ideal, mem : ('rt-arr-flag -> 0), pool :
	                   < socket-rcv(SOCKET-TYPE-1) : Thread | st : read > ;
	                   < rt-main : Thread | st : wait > ; empty >
	< VOTE-DES : Vote | cpu : ideal,
			    mem : (('throttle-gear1 -> (gear: 5 ,auto-or-manual: 0)),
			      ('side-status -> 0), ('branch-status -> 0),
			      ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 0),
			      ('to-manual-status -> 0), ('auto-ack-status -> 0),
			      ('manual-ack-status -> 0), ('auto-status -> 0),
			      ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-MANNUL )),
			      ('fsm-rt -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-MANNUL )),
			      ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-MANNUL )) ),
			    pool :
	                    < socket-rcv(SOCKET-TYPE-1) : Thread | st : read > ;
	                    < socket-rcv(SOCKET-TYPE-CAN2NET) : Thread | st : read > ;	
                            < receive-throttle : Thread | st : receive > ;
                            < fsm-run : Thread | st : while-fsm-start > ; empty > 
	< CON-DES : CtrlBox | controls : EVENT-MANNAL-TO-AUTO ; nil >
	< OUT-DES : OutputBrd | gear : 5, auto-or-manual : 0 >
	[==> COM-DES : PORT-LKJ | none ] 
	[==> COM-DES : SOCKET-TYPE-0 | none ]
	[==> CORE-DES : SOCKET-TYPE-1 | none ]
	[==> VOTE-DES : SOCKET-TYPE-1 | none ]
	[==> VOTE-DES : SOCKET-TYPE-CAN2NET | none ] 
	[==> VOTE-DES : PORT-CANINOUT | none ]
	[==> CON-DES : SOCKET-TYPE-5 | none ]
	[==> OUT-DES : PORT-CANINOUT | none ] .

    
    var M : Memory .
    
    --- to see if the system is on the procedure to switch to manual mode
    op switchToManual : Configuration -> Bool .
    eq switchToManual( < VOTE-DES : Vote | mem : M > C:Configuration )
      = M['fsm-state] == FSM-MANUAL or M['fsm-state] == FSM-START-MANUAL
	or M['fsm-state] == FSM-ACK-MANUAL or M['fsm-state] == FSM-ERGE-AUTO
	or M['fsm-state] == FSM-OVER-TIME .

    --- to see if the optimized result enable the auto controlling
    op isAutoEnable : Configuration -> Bool .
    eq isAutoEnable( < VOTE-DES : Vote | mem : M > C:Configuration )
      = ((M['fsm-temp]).rt-core).rt-enable-status == 1 .

endtom)

(tomod SYSTEM-VERIFICATION is
    protecting SYSTEM .
    including TIMED-MODEL-CHECKER .

    op timeoutControl : Configuration -> Bool .
    eq timeoutControl( < OUT-DES : OutputBrd | gear : 0, auto-or-manual : 1 >
	  C:Configuration )
      = true .
    eq timeoutControl( C:Configuration ) = false [owise] .

    op autoControl : Configuration -> Bool .
    eq autoControl( < OUT-DES : OutputBrd | auto-or-manual : 1 > C:Configuration )
      = true .
    eq autoControl( C:Configuration ) = false [owise] .

    op manualControl : Configuration -> Bool .
    eq manualControl( < OUT-DES : OutputBrd | auto-or-manual : 0 > C:Configuration )
      = true .
    eq manualControl( C:Configuration ) = false [owise] .

    vars N M : Nat .
    var C : Configuration .
    
    op _.gearEquals`(_`) : Configuration Nat -> Bool .
    eq (< OUT-DES : OutputBrd | gear : N > C:Configuration).gearEquals(M)
      = N == M .

    op slide : -> Prop .
    eq {C:Configuration} |= slide = timeoutControl(C:Configuration) .

    op auto : Nat -> Prop .
    eq {C} |= auto(N) = autoControl(C) and (C).gearEquals(N) .

    op manual : Nat -> Prop .
    eq {C} |= manual(N) = manualControl(C) and (C).gearEquals(N) .


    eq sys(2) =
	< lkj : LKJ | data : nil >
	< COM-DES : Comm | cpu : ideal, mem : empty, pool :
			   < socket-rcv(SOCKET-TYPE-0) : Thread | st : read > ;
	                   < net-thread : Thread | st : read > ; empty >
	< CORE-DES : Core | cpu : ideal, mem : ('rt-arr-flag -> 0), pool :
	                   < socket-rcv(SOCKET-TYPE-1) : Thread | st : read > ;
	                   < rt-main : Thread | st : wait > ; empty >
	< VOTE-DES : Vote | cpu : ideal,
			    mem : (('throttle-gear1 -> (gear: 5 ,auto-or-manual: 0)),
			      ('side-status -> 0), ('branch-status -> 0),
			      ('fsm-state -> FSM-MANUAL), ('to-auto-status -> 0),
			      ('to-manual-status -> 0), ('auto-ack-status -> 0),
			      ('manual-ack-status -> 0), ('auto-status -> 0),
			      ('rt-vote -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-AUTO )),
			      ('fsm-rt -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-MANNUL )),
			      ('fsm-temp -> (rt-core: (rt-gear: 5 ,rt-enable-status: 1)
				  ,rt-control-status: CONTROL-MANNUL )) ),
			    pool :
	                    < socket-rcv(SOCKET-TYPE-1) : Thread | st : read > ;
	                    < socket-rcv(SOCKET-TYPE-CAN2NET) : Thread | st : read > ;	
                            < receive-throttle : Thread | st : receive > ;
                            < fsm-run : Thread | st : while-fsm-start > ; empty > 
	< CON-DES : CtrlBox | controls : nil >
	< OUT-DES : OutputBrd | gear : 5, auto-or-manual : 0 >
	[==> COM-DES : PORT-LKJ | none ] 
	[==> COM-DES : SOCKET-TYPE-0 | none ]
	[==> CORE-DES : SOCKET-TYPE-1 | none ]
	[==> VOTE-DES : SOCKET-TYPE-1 | none ]
	[==> VOTE-DES : SOCKET-TYPE-CAN2NET | none ] 
	[==> VOTE-DES : PORT-CANINOUT | none ]
	[==> CON-DES : SOCKET-TYPE-5 | none ]
	[==> OUT-DES : PORT-CANINOUT | none ] .
    
endtom)

(fmod FRAME is
    sort Frame .
endfm)
    
(omod SOCKET is
    protecting FRAME .
    sort SocketType .

    op `[_==>_:_|_`] : Oid Oid SocketType Frame -> Msg [ctor] .
endom)

(fmod QUEUE is
    protecting FRAME .
    sort Queue .

    pr NAT .
    subsort Nat < Frame .

    op nil : -> Queue [ctor] .
    op _::_ : Frame Queue -> Queue [ctor] .

    vars F F' : Frame .
    var Q : Queue .

    --- operation _peek_ requires the Queue to be not empty
    op peek : Queue -> Frame .
    eq peek(F :: Q) = F .

    op enqueue : Frame Queue -> Queue .
    eq enqueue(F, nil) = F :: nil .
    eq enqueue(F, F' :: Q) = F' :: enqueue(F, Q) .

    op dequeue : Queue -> Queue .
    eq dequeue(nil) = nil .
    eq dequeue(F :: Q) = Q .
endfm)

(fmod BUFFER is
    protecting QUEUE .
    sort Buffer .
    subsort Queue < Buffer .
endfm)

(fmod MEMORY is
    protecting QID .
    sort Memory .
    sorts Variable Value Pair .
    subsort Qid < Variable .

    subsort Nat < Value .
    op null : -> Value .
    
    op `(_->_`) : Variable Value -> Pair [ctor] .

    op empty : -> Memory [ctor] .
    subsort Pair < Memory .
    op _`,_ : Memory Memory -> Memory [ctor assoc comm id: empty] .

    var X : Variable .
    vars V V' : Value .
    var M : Memory .

    --- assignment
    op _`[_:=_`] : Memory Variable Value -> Memory .
    eq ((X -> V), M)[X := V'] = (X -> V'), M .
    eq M[X := V'] = (X -> V'), M [owise] .

    --- evaluation
    op _`[_`] : Memory Variable -> Value .
    eq ((X -> V), M)[X] = V .
    eq M[X] = null [owise] .

endfm)

(omod THREAD is
    sort ThreadID .
    subsort ThreadID < Oid .

    class Thread .
endom)

(omod THREADPOOL is
    protecting THREAD .
    sort ThreadPool .

    op empty : -> ThreadPool [ctor] .
    op _;_ : Object ThreadPool -> ThreadPool [ctor] .

    ops a b c : -> Object .

    vars O O' : Object .
    var P : ThreadPool .
    
    --- operation _peek_ requires the Pool to be not empty
    op peek : ThreadPool -> Object .
    eq peek(O ; P) = O .

    op enqueue : Object ThreadPool -> ThreadPool .
    eq enqueue(O, empty) = O ; empty .
    eq enqueue(O, O' ; P) = O' ; enqueue(O, P) .

    op dequeue : ThreadPool -> ThreadPool .
    eq dequeue(empty) = empty .
    eq dequeue(O ; P) = P .
endom)
    
(omod BOARD is
    protecting BUFFER .
    protecting MEMORY .
    protecting THREADPOOL .

    class Board | mem : Memory, pool : ThreadPool .
endom)

(omod COMM is
    protecting BOARD .

    class Comm .
    subclass Comm < Board .

endom)

(omod CORE is
    protecting BOARD .

    class Core .
    subclass Core < Board .

endom)

(omod VOTE is
    protecting BOARD .

    class Vote .
    subclass Vote < Board .

endom)

(fmod DATA is
    sort Data .
endfm)
        
(omod LKJ is
    protecting DATA .
    class LKJ | data : Data .
endom)

(omod CTRL-BOX is
    protecting DATA .
    class CtrlBox | data : Data .
endom)
    
(omod SYSTEM is
    protecting SOCKET .
    protecting COMM .
    protecting CORE .
    protecting VOTE .
    protecting LKJ .
    protecting CTRL-BOX .
    pr QUEUE .
    pr THREADPOOL .
endom)
    
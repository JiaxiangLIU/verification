(fmod TO-STATUS is
    --- system status
    sort SystemStatus .
    ops SYS-INIT SYS-FAULT SYS-MAINTENANCE SYS-LAUNCHED SYS-STANDBY
	SYS-NORMAL SYS-AUTOCONTROL SYS-MAX : -> SystemStatus .

    --- trip status
    sort TripStatus .
    ops TRIP-DATA-RECVING TRIP-DATA-COMPLETE TRIP-MARSHALLING-CONFIRM 
	TRIP-INIT TRIP-START TRIP-PAUSE TRIP-COMPLETE TRIP-ANOMALY 
	TRIP-MAX : -> TripStatus .
    
    --- the sources where the events come
    sort EventSource .
    ops SOURCE-COM SOURCE-CORE SOURCE-CONTROL SOURCE-VOTE
	SOURCE-INPUT SOURCE-OUTPUT MAX-SOURCE : -> EventSource .

    --- control status
    sort ControlStatus .
    ops CONTROL-MANNUL CONTROL-AUTO : -> ControlStatus .

    --- events
    sort EventType .

    --- events on COMM
    ops EVENT-COM-HEARTBEAT EVENT-COM-REGISTER EVENT-LKJ-VERSION-DIFFERENCE
	EVENT-TRIP-STATUS-NOTICE EVENT-DUTY-ASSISTING-CHANGE
	EVENT-ROUTE-DATA-SEND EVENT-ROUTE-DATA-CURVE EVENT-ROUTE-DATA-LIMIT
	EVENT-ROUTE-DATA-TELESEME EVENT-ROUTE-DATA-TUNNEL EVENT-ROUTE-DATA-STATION
	EVENT-FRONT-SPEED-LIMIT EVENT-FRONT-BRANCH-TRANSFER EVENT-FRONT-SIDE-LINE-PASS
	EVENT-MARSHALLING-RE-CHANGE EVENT-REAL-TIME-INFO EVENT-ROUTE-VERSION-SEND
	EVENT-TRIP-CHANGE EVENT-MARSHALLING-CHANGE EVENT-CLOCK-SYNC
	EVENT-REAL-TIME-ERROR EVENT-BASE-LINE-DATA-ERROR EVENT-ROUTE-EXTRACT-FAILUER
	EVENT-MARSHALLING-ERROR EVENT-STATION-ERROR EVENT-COM-EXTERNAL-CAN-FAULT
	EVENT-COM-INTERNAL-CAN-FAULT EVENT-COM-MAX : -> EventType .

    --- events on CORE
    ops EVENT-CORE-HEARTBEAT EVENT-CORE-REGISTER EVENT-ROUTE-VERSION-RESULT
	EVENT-TRIP-OPT-COMPLETE EVENT-ROUTE-DATA-SEND-ACK EVENT-ROUTE-DATA-CURVE-ACK
	EVENT-ROUTE-DATA-LIMIT-ACK EVENT-ROUTE-DATA-TELESEME-ACK EVENT-ROUTE-DATA-TUNNEL-ACK
	EVENT-ROUTE-DATA-STATION-ACK EVENT-REAL-TIME-CTRL EVENT-CORE-CAN-FAULT
	EVENT-TRIP-ROUTE-ERROR EVENT-TRIP-POSITION-ERROR EVENT-TRIP-PARA-ERROR
	EVENT-TRIP-OPT-ERROR EVENT-TEMP-OPT-ERROR EVENT-CORE-MAX : -> EventType .

    --- events on Control-Box
    ops EVENT-CTRL-BOX-HEARTBEAT EVENT-CTRL-BOX-REGISTER EVENT-CTRL-BOX-MASTER-SET
	EVENT-CTRL-BOX-MASTER-RELIEVE EVENT-TRIP-INIT-START EVENT-MANNAL-TO-AUTO
	EVENT-AUTO-TO-MANNAL EVENT-TWO-GEAR-TO-MANNUL EVENT-SYS-TO-MAINTENANCE
	EVENT-EXIT-MAINTENANCE EVENT-KEEP-AUTO EVENT-KEEP-MANNAL
	EVENT-SEND-AUTO-GEAR EVENT-GEAR8-AUTO-CONFIRM-ACK EVENT-TRIP-OVER
	EVENT-VOTE-HEARTBEAT-STOP EVENT-CTRL-BOX-CAN-FAULT EVENT-CTRL-BOX-PARSE-ERROR
	EVENT-CTRL-MAX : -> EventType .

    --- events on VOTE
    ops EVENT-VOTE-HEARTBEAT EVENT-BROADCAST-COM-ADDR EVENT-MASTER-VOTE-EXCHANGE
	EVENT-LOCK-SCREEN EVENT-VOTE-TRIP-INIT-START EVENT-SYS-TRIP-STATUS-SEND
	EVENT-MANNAL-GEAR-CHANGE EVENT-TWO-GEAR-CONFIRM EVENT-MANNAL-COMPLETE
	EVENT-AUTO-COMPLETE EVENT-BRANCH-TRANSFER-TIME EVENT-SPEED-LIMIT-TIME
	EVENT-SIG-CHANGE-TIME EVENT-AUTO-TIME-ALARM EVENT-MANNUL-TIME-ALARM
	EVENT-BRAKE-GEAR0 EVENT-GEAR8-AUTO-CONFIRM EVENT-VOTE-UPDATE-MARSHALLING
	EVENT-VOTE-SENT-MARSHALLING EVENT-DISP-AUTO EVENT-DISP-MANNAL
	EVENT-DISP-REAL-TIME-INFO EVENT-VOTE-TRIP-INIT-COMPLETE EVENT-VOTE-BRANCH-TRANSFER-PASS
	EVENT-VOTE-SIDE-LINE-PASS-START EVENT-VOTE-SIDE-LINE-PASS-END EVENT-TRIP-UPDATE
	EVENT-SEND-TRIP-TO-CORE EVENT-MAR-UPDATE EVENT-SEND-MAR-TO-CORE
	EVENT-BOARD-REGISTER-FAILUER EVENT-MASTER-COM-HEARTBEAT-STOP EVENT-ALL-COM-HEARTBEAT-STOP
	EVENTH-CORE-HEARTBEAT-STOP EVENT-MASTER-CTRL-HEARTBEAT-STOP EVENT-RELAY-FAULT
	EVENT-COM-FAULT-HANDLE EVENT-CORE-FAULT-HANDLE EVENT-CTRL-FAULT-HANDLE
	EVENT-VOTE-FAULT-HANDLE EVENT-VOTE-MAX : -> EventType .

    --- events on INPUT
    ops EVENT-DIGITAL-ANALOG EVENT-INPUT-MAX : -> EventType .

    --- events on OUTPUT
    ops EVENT-HEARTBEAT-STOP EVENT-OUTPUT-MAX : -> EventType .    

endfm)

(omod VALUE is
    protecting TO-STATUS .
    sort Value .

    subsort Nat < Value .
    subsort EventSource < Value .
    subsort Oid < Value .
    subsort SystemStatus < Value .
    subsort TripStatus < Value .
    op null : -> Value .
endom)
    
(omod COMMAND is
    protecting TO-STATUS .
    protecting VALUE .
    sort Command .

    op _|_|_ : EventSource EventType Value -> Command [ctor] .

endom)

(omod DATA is
    protecting TO-STATUS .
    protecting VALUE .
    sort Data .

    op _|_|_|_|_ : EventSource EventType Value Nat Nat -> Data [ctor] .

endom)
            
(omod FRAME is
    protecting COMMAND .
    protecting DATA .
    sort Frame .
    sorts DataFrame CommandFrame .
    subsorts DataFrame CommandFrame < Frame .
    
    op command : Command -> CommandFrame [ctor] .
    op data : Data -> DataFrame [ctor] .

    sort MaybeFrame .
    op none : -> MaybeFrame [ctor] .
    op some_ : Frame -> MaybeFrame [ctor] .

endom)
    
(omod SOCKET is
    protecting NAT .
    protecting FRAME .
    sort SocketType .

    --- define a msg to send frames to some socket port
    msg `[==>_:_|_`] : Oid SocketType MaybeFrame -> Msg .

    op SOCKET-TYPE-0 : -> SocketType [ctor] . --- 0x80
    op SOCKET-TYPE-1 : -> SocketType [ctor] . --- 0x40
    op SOCKET-TYPE-2 : -> SocketType [ctor] . --- 0x20
    op SOCKET-TYPE-3 : -> SocketType [ctor] . --- 0x10
    op SOCKET-TYPE-4 : -> SocketType [ctor] . --- 0x08
    op SOCKET-TYPE-5 : -> SocketType [ctor] . --- 0x04
    op SOCKET-TYPE-CAN2NET : -> SocketType [ctor] . --- 0x02
    op COM-SOC : -> SocketType . --- 0x20
    op DAT-SOC : -> SocketType . --- 0x04
    op DAT-VOTE-SOC : -> SocketType . --- 0x08

    eq COM-SOC = SOCKET-TYPE-2 .
    eq DAT-SOC = SOCKET-TYPE-5 .
    eq DAT-VOTE-SOC = SOCKET-TYPE-4 .
endom)

    ***(
(omod QUEUE is
    protecting FRAME .
    sort Queue .

    pr NAT .
    subsort Nat < Frame .

    op nil : -> Queue [ctor] .
    op _::_ : Frame Queue -> Queue [ctor] .

    vars F F' : Frame .
    var Q : Queue .

    --- operation _peek_ requires the Queue to be not empty
    op peek : Queue -> Frame .
    eq peek(F :: Q) = F .

    op enqueue : Frame Queue -> Queue .
    eq enqueue(F, nil) = F :: nil .
    eq enqueue(F, F' :: Q) = F' :: enqueue(F, Q) .

    op dequeue : Queue -> Queue .
    eq dequeue(nil) = nil .
    eq dequeue(F :: Q) = Q .
endom)

(omod BUFFER is
    protecting QUEUE .
    sort Buffer .
    subsort Queue < Buffer .
endom)
    )

(omod MEMORY is
    protecting QID .
    protecting VALUE .
    sort Memory .
    sorts Variable Pair .
    subsort Qid < Variable .

    op `(_->_`) : Variable Value -> Pair [ctor] .

    op empty : -> Memory [ctor] .
    subsort Pair < Memory .
    op _`,_ : Memory Memory -> Memory [ctor assoc comm id: empty] .

    var X : Variable .
    vars V V' : Value .
    var M : Memory .

    --- assignment
    op _`[_:=_`] : Memory Variable Value -> Memory .
    eq ((X -> V), M)[X := V'] = (X -> V'), M .
    eq M[X := V'] = (X -> V'), M [owise] .

    --- evaluation
    op _`[_`] : Memory Variable -> Value .
    eq ((X -> V), M)[X] = V .
    eq M[X] = null [owise] .

endom)

(omod THREAD is
    sort ThreadID .
    subsort ThreadID < Oid .

    sort Status .
    
    class Thread | st : Status .
endom)

(omod THREADPOOL is
    protecting THREAD .
    sort ThreadPool .

    op empty : -> ThreadPool [ctor] .
    op _;_ : Object ThreadPool -> ThreadPool [ctor] .

    ops a b c : -> Object .

    vars O O' : Object .
    var P : ThreadPool .
    
    --- operation _peek_ requires the Pool to be not empty
    op peek : ThreadPool -> Object .
    eq peek(O ; P) = O .

    op enqueue : Object ThreadPool -> ThreadPool .
    eq enqueue(O, empty) = O ; empty .
    eq enqueue(O, O' ; P) = O' ; enqueue(O, P) .

    op dequeue : ThreadPool -> ThreadPool .
    eq dequeue(empty) = empty .
    eq dequeue(O ; P) = P .
endom)
    
(omod BOARD is
---    protecting BUFFER .
    protecting MEMORY .
    protecting THREADPOOL .

    class Board | cpu : Object, mem : Memory, pool : ThreadPool .

    op ideal : -> Object .

    ops CON-DES COM-DES CORE-DES VOTE-DES : -> Oid .

endom)

(omod COMM is
    protecting BOARD .

    class Comm .
    subclass Comm < Board .

endom)

(omod CORE is
    protecting TO-STATUS .
    protecting BOARD .
    protecting SOCKET .

    class Core .
    subclass Core < Board .

    --- threads
    op socket-rcv : SocketType -> ThreadID [ctor] .
    ops rt-main main : -> ThreadID [ctor] .
    op command-frame-rcv-handle : -> ThreadID .
    
    op read : -> Status .
    op frame-parse : Frame -> Status .
    op threadpool-add : ThreadID Command -> Status .
    op data-frame-rcv-handle : Data -> Status .
    op done : -> Status .

    
    vars O O' : Oid .
    var S : SocketType .
    var N : Nat .
    var M : Memory .
    vars T T' : Object .
    var P : ThreadPool .
    var F : Frame .
    subsort Nat < Oid .
    var OB : Object .
    var C : Command .
    var NEW : Object .
    var CON : Configuration .
    var D : Data .
    var V : Value .
    var SYSST : SystemStatus .
    var TRIPST : TripStatus .
    vars AMOUNT CNT : Nat .
    
    op msg1 : Oid Nat -> Msg .
    op cpu1 : -> Object .
    op mem1 : -> Memory .
    op pool1 : -> ThreadPool .
    op ftest : -> Frame .
    op com1 : -> Command .
    op data1 : -> Data .
    ops a b c : -> Object .

    ops test1 test2 test3 test4 test5 test6 : -> Configuration .
    ops test7 test8 test9 : -> Configuration .
    eq test1 = < 1 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : a ; empty >
	[==> 1 : SOCKET-TYPE-2 | none ]  .
    eq test2 = < 2 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : ('master-commu-addr -> SOURCE-COM), pool : empty >
	[==> 2 : SOCKET-TYPE-2
	  | some command( SOURCE-VOTE | EVENT-BROADCAST-COM-ADDR | SOURCE-COM ) ]  .    
    eq test3 = < 3 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : mem1, pool : empty >
	[==> 3 : SOCKET-TYPE-2 | some data(data1) ]  .
    eq test4 = < 4 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('master-commu-addr -> SOURCE-COM), ('sys-status -> SOURCE-COM)), 
	pool : empty >
	[==> 4 : SOCKET-TYPE-2
	  | some command( SOURCE-VOTE | EVENT-MASTER-VOTE-EXCHANGE | SYS-LAUNCHED ) ]  .
    eq test5 = < 5 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('trip-status -> SOURCE-COM), ('sys-status -> SOURCE-COM)), 
	pool : empty >
	[==> 5 : SOCKET-TYPE-2
	  | some command( SOURCE-VOTE | EVENT-SYS-TRIP-STATUS-SEND | TRIP-START ) ]  .
    eq test6 = < 6 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('trip-status -> SOURCE-COM), ('sys-status -> SOURCE-COM)), 
	pool : empty >
	[==> 6 : SOCKET-TYPE-2
	  | some command( SOURCE-COM | EVENT-SYS-TRIP-STATUS-SEND | TRIP-START ) ]  .
    eq test7 = < 7 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('trip-status -> SOURCE-COM), ('sys-status -> SOURCE-COM)), 
	pool : empty >
	[==> 7 : SOCKET-TYPE-2
	  | some data( SOURCE-COM | EVENT-FRONT-SPEED-LIMIT | TRIP-START | 0 | 1 ) ]  .
    eq test8 = < 8 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('rt-arr-flag -> 0), ('rt-comm -> null)), 
	pool : empty >
	[==> 8 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-REAL-TIME-INFO | 9 | 0 | 1 ) ]  .
    eq test9 = < 9 : Core | cpu : < socket-rcv(SOCKET-TYPE-2) : Thread | st : read >,
	mem : (('rt-arr-flag -> 0), ('rt-comm -> null)), 
	pool : pool1 >
	[==> 9 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-CLOCK-SYNC | 9 | 0 | 1 ) ]  .   

    --- rl [schedule] :
    --- assume this transition is instantaneous
    eq < O : Core | cpu : ideal, pool : (T ; P) > = < O : Core | cpu : T, pool : P > .

    --- wait to read msgs, if existing, then read
    crl [core-socket-rcv-n-read-some] :
	< O : Core | cpu : T, pool : P >
      	[==> O : S | some F ]
      => < O : Core | cpu : ideal, pool : enqueue(T', P) >
	[==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T
	  /\ T' := < socket-rcv(S) : Thread | st : frame-parse(F) > .

    --- wait to read msgs, if not exisiting, then switch
    crl [core-socket-rcv-n-read-none] :
	< O : Core | cpu : T, pool : P > [==> O : S | none ]
      => < O : Core | cpu : ideal, pool : enqueue(T, P) > [==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T .

    --- parse frames, including commands and data
    eq frame-parse(command(C)) = threadpool-add(command-frame-rcv-handle, C) .
    eq frame-parse(data(D)) = data-frame-rcv-handle(D) .

    op handle : Command -> Status .

    --- create a new thread in pool to handle commands, then return to while loop reading
    crl [core-threadpool-add-command] :
	< O : Core | cpu : T, pool : P >
      => < O : Core | cpu : ideal, pool : enqueue(T', enqueue(NEW, P)) >
      if < socket-rcv(S) : Thread | st : threadpool-add(command-frame-rcv-handle, C) > := T
	  /\ T' := < socket-rcv(S) : Thread | st : read >
	  /\ NEW := < command-frame-rcv-handle : Thread | st : handle(C) > . 

    op limit-data-rcv-handle : Value -> Status .
    op realtime-data-rcv-handle : Value -> Status .

    --- data_frame_rcv_handle
    eq data-frame-rcv-handle( SOURCE-COM | EVENT-FRONT-SPEED-LIMIT | V | AMOUNT | CNT )
      = limit-data-rcv-handle(V) .
    eq data-frame-rcv-handle( SOURCE-COM | EVENT-REAL-TIME-INFO | V | AMOUNT | CNT )
      = realtime-data-rcv-handle(V) .
    eq data-frame-rcv-handle( S:EventSource | E:EventType | V | AMOUNT | CNT )
      = done [owise] .
    *** DONE for CORE
        
    --- behavior of limit_data_rcv_handle( ) in data_frame_rcv_handle
    eq limit-data-rcv-handle(V) = done .

    --- behavior of realtime_data_rcv_handle( ) in data_frame_rcv_handle
    crl [core-realtime-data-rcv-handle] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['rt-comm := V]['rt-arr-flag := 1],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : realtime-data-rcv-handle(V) > := T
	  /\ T' := < socket-rcv(S) : Thread | st : done > . 

    --- definition of "done" status of the thread socekt_rcv():
    --- back to loop reading
    eq < socket-rcv(S) : Thread | st : done >
      = < socket-rcv(S) : Thread | st : read > .
    
    op set-commu-addr : Oid -> Status .
    op set-sys-status : SystemStatus -> Status .
    op set-trip-status : TripStatus -> Status .
      
    --- command_frame_rcv_handle
    eq handle( SOURCE-VOTE | EVENT-BROADCAST-COM-ADDR | V )
      = if V == SOURCE-COM then set-commu-addr(COM-DES) 
        else done fi .
    eq handle( SOURCE-VOTE | EVENT-MASTER-VOTE-EXCHANGE | V )
      = set-sys-status(V) .
    eq handle( SOURCE-VOTE | EVENT-SYS-TRIP-STATUS-SEND | V ) 
      = set-trip-status(V) .
    eq handle( S:EventSource | E:EventType | V ) = done [owise] .
    *** DONE for CORE 

    --- behavior of set_commu_addr( ) in command_frame_rcv_handle
    crl [core-set-commu-addr] :
	< O : Core | cpu : T, mem : M, pool : P >
      => if O' == COM-DES 
	 then < O : Core | cpu : ideal, mem : M['master-commu-addr := O'], pool : enqueue(T', P) >
	 else < O : Core | cpu : ideal, mem : M, pool : enqueue(T', P) > fi
      if < command-frame-rcv-handle : Thread | st : set-commu-addr(O') > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : done > . 

    --- behavior of set_sys_status( ) in command_frame_rcv_handle
    crl [core-set-sys-status] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['sys-status := SYSST], pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-sys-status(SYSST) > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : done > . 

    --- behavior of set_trip_status( ) in command_frame_rcv_handle
    crl [core-set-trip-status] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['trip-status := TRIPST], pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-trip-status(TRIPST) > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : done > . 

    --- thread command_frame_rcv_handle done
    crl [core-command-frame-rcv-handle-done] :
	< O : Core | cpu : T > => < O : Core | cpu : ideal >
      if < command-frame-rcv-handle : Thread | st : done > := T .

    ***********************************
    *** behavior of thread rt-main
    ***********************************

    op wait : -> Status .
    op rt-processing : -> Status .
    op rt-send : -> Status .
    op rt-process : Value -> Value .
      
    --- rt-main always waits for the realtime data
    crl [core-rt-main-wait-some] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['rt-arr-flag := 0]['rt-in := M['rt-comm]],
		      pool : enqueue(T', P) >
      if < rt-main : Thread | st : wait > := T
	  /\ M['rt-arr-flag] == 1
	  /\ T' := < rt-main : Thread | st : rt-processing > .
    crl [core-rt-main-wait-none] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, pool : enqueue(T, P) >
      if < rt-main : Thread | st : wait > := T
	  /\ M['rt-arr-flag] == 0 .

    --- behavior of rt-process in rt-main
    crl [core-rt-main-processing] :
	< O : Core | cpu : T, mem : M, pool : P >
      => < O : Core | cpu : ideal, mem : M['rt-core := rt-process(M['rt-in])],
		      pool : enqueue(T', P) >
      if < rt-main : Thread | st : rt-processing > := T
	  /\ T' := < rt-main : Thread | st : rt-send > .

    --- behavior of frame_encap (sending the processed result) in rt-main
    crl [core-rt-main-send-succ] :
	< O : Core | cpu : T, mem : M, pool : P > [==> VOTE-DES : SOCKET-TYPE-1 | none]
      => < O : Core | cpu : ideal, pool : enqueue(T', P) >
         [==> VOTE-DES : SOCKET-TYPE-1
	      | some data( SOURCE-CORE | EVENT-REAL-TIME-CTRL | M['rt-core] | 0 | 0 )]
      if < rt-main : Thread | st : rt-send > := T
	  /\ T' := < rt-main : Thread | st : wait > .    
    crl [core-rt-main-send-block] :
	< O : Core | cpu : T, mem : M, pool : P > [==> VOTE-DES : SOCKET-TYPE-1 | some F]
      => < O : Core | cpu : ideal, pool : enqueue(T, P) >
         [==> VOTE-DES : SOCKET-TYPE-1 | some F]
      if < rt-main : Thread | st : rt-send > := T .

    ops test10 test11 : -> Configuration .
    op test : Nat -> Configuration .
    eq test10 = < 10 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 0), ('rt-arr-flag -> 1)), 
	pool : pool1 >
	[==> 10 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-CLOCK-SYNC | 9 | 0 | 1 ) ] .   
    eq test11 = < 10 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 0), ('rt-arr-flag -> 0)), 
	pool : pool1 >
	[==> 10 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-CLOCK-SYNC | 9 | 0 | 1 ) ] .
    eq test(12) = < 12 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 0), ('rt-arr-flag -> 1)), 
	pool : empty >
	[==> 10 : SOCKET-TYPE-2 | some data( SOURCE-COM | EVENT-CLOCK-SYNC | 9 | 0 | 1 ) ] .
    eq test(13) = < 13 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 9), ('rt-arr-flag -> 1)), 
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | none] .
    eq test(14) = < 14 : Core | cpu : < rt-main : Thread | st : wait >,
	mem : (('rt-in -> null), ('rt-comm -> 9), ('rt-arr-flag -> 1)), 
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1 | some ftest ] . 

endom)

(fmod RT-VOTE is
    protecting TO-STATUS .
    protecting VALUE .
    sort RtVote .
    subsort RtVote < Value .
    
    op `(rt-core:_`,rt-control-status:_`) : Value ControlStatus -> RtVote [ctor] .
endfm)

(fmod THROTTLE-GEAR is
    protecting TO-STATUS .
    protecting VALUE .
    protecting NAT .
    sort ThrottleGear .
    subsort ThrottleGear < Value .

    op `(gear:_`,auto-or-manual:_`) : Nat Nat -> ThrottleGear [ctor] .

    vars N M : Nat .
    
    op _.gear : ThrottleGear -> Nat .
    eq (gear: N ,auto-or-manual: M ).gear = N .

    op _.auto-or-manual : ThrottleGear -> Nat .
    eq (gear: N ,auto-or-manual: M ).auto-or-manual = M .
endfm)
    
(omod VOTE is
    protecting TO-STATUS .
    protecting BOARD .
    protecting SOCKET .
    protecting RT-VOTE .
    protecting THROTTLE-GEAR .

    class Vote .
    subclass Vote < Board .

    --- threads
    op socket-rcv : SocketType -> ThreadID [ctor] .
    op command-frame-rcv-handle : -> ThreadID .
    
    op read : -> Status .
    op frame-parse : Frame -> Status .
    op threadpool-add : ThreadID Command -> Status .
    op data-frame-rcv-handle : Data -> Status .
    op done : -> Status .
    op _;_ : Status Status -> Status [ctor assoc id: done] .

    
    vars O O' : Oid .
    var S : SocketType .
    var N : Nat .
    var M : Memory .
    vars T T' : Object .
    var P : ThreadPool .
    var F : Frame .
    subsort Nat < Oid .
    var OB : Object .
    var C : Command .
    var NEW : Object .
    var CON : Configuration .
    vars D DATA : Data .
    var V : Value .
    var SYSST : SystemStatus .
    var TRIPST : TripStatus .
    vars AMOUNT CNT : Nat .
    vars ST ST' ST'' : Status .
    
    op msg1 : Oid Nat -> Msg .
    op cpu1 : -> Object .
    op mem1 : -> Memory .
    op pool1 : -> ThreadPool .
    op ftest : -> Frame .
    op com1 : -> Command .
    op data1 : -> Data .
    ops a b c : -> Object .

    --- scheduling strategy
    --- assume this transition is instantaneous
    eq < O : Vote | cpu : ideal, pool : (T ; P) > = < O : Vote | cpu : T, pool : P > .
    
    **********************************
    *** behavior of socket-rcv
    *********************************
    
    --- wait to read msgs, if existing, then read
    crl [vote-socket-rcv-n-read-some] :
	< O : Vote | cpu : T, pool : P >
      	[==> O : S | some F ]
      => < O : Vote | cpu : ideal, pool : enqueue(T', P) >
	[==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T
	  /\ T' := < socket-rcv(S) : Thread | st : frame-parse(F) > .

    --- wait to read msgs, if not exisiting, then switch
    crl [vote-socket-rcv-n-read-none] :
	< O : Vote | cpu : T, pool : P > [==> O : S | none ]
      => < O : Vote | cpu : ideal, pool : enqueue(T, P) > [==> O : S | none ]
      if < socket-rcv(S) : Thread | st : read > := T .

    --- parse frames, including commands and data
    eq frame-parse(command(C)) = threadpool-add(command-frame-rcv-handle, C) .
    eq frame-parse(data(D)) = data-frame-rcv-handle(D) .

    op handle : Command -> Status .

    --- create a new thread in pool to handle commands, then return to while loop reading
    crl [vote-threadpool-add-command] :
	< O : Vote | cpu : T, pool : P >
      => < O : Vote | cpu : ideal, pool : enqueue(T', enqueue(NEW, P)) >
      if < socket-rcv(S) : Thread | st : threadpool-add(command-frame-rcv-handle, C) > := T
	  /\ T' := < socket-rcv(S) : Thread | st : read >
	  /\ NEW := < command-frame-rcv-handle : Thread | st : handle(C) > .

    **********************************
    *** behavior of data-frame-rcv-handle
    **********************************

    --- the end of function data-frame-rcv-handle: "done"
    --- definition of "done" status of the thread socekt_rcv():
    --- back to loop reading
    eq < socket-rcv(S) : Thread | st : done >
      = < socket-rcv(S) : Thread | st : read > .

    op set-branch-status : Nat -> Status .
    op set-branch-info : Value -> Status .
    op set-side-status : Nat -> Status .
    op set-side-info : Value -> Status .
    op ctrbox-data : EventType -> Status .
    op handle-event-front-side-line-pass : Value -> Status .
    op rt-handle : Value -> Status .

    --- data_frame_rcv_handle
    eq data-frame-rcv-handle( SOURCE-COM | EVENT-FRONT-BRANCH-TRANSFER | V | AMOUNT | CNT )
      = set-branch-status(1) ; set-branch-info(V) ; done .
    eq data-frame-rcv-handle( SOURCE-COM | EVENT-FRONT-SIDE-LINE-PASS | V | AMOUNT | CNT )
      = handle-event-front-side-line-pass(V) .
    eq data-frame-rcv-handle( SOURCE-CORE | EVENT-REAL-TIME-CTRL | V | AMOUNT | CNT )
      = rt-handle(V) .
    eq data-frame-rcv-handle( S:EventSource | E:EventType | V | AMOUNT | CNT )
      = done [owise] .
    *** DONE for VOTE
    

    --- behavior of set_branch_status( ) in data_frame_rcv_handle
    crl [vote-set-branch-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['branch-status := 1],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : set-branch-status(1) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .

    --- behavior of set_branch_info( ) in data_frame_rcv_handle
    crl [vote-set-branch-info] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['branch-info := V],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : set-branch-info(V) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .    

    --- behavior/definition of handle-event-front-side-line-pass
    ceq < O : Vote | cpu : < socket-rcv(S) : Thread | st : ST >, mem : M >
      = if M['side-status] =/= 0
	then < O : Vote | cpu : < socket-rcv(S) : Thread | st : done > >
	else < O : Vote | cpu : < socket-rcv(S) : Thread | st : ST' > >
        fi
      if handle-event-front-side-line-pass(V) := ST
	  /\ ST' := set-side-status(1) ; set-side-info(V) ;
      	            ctrbox-data(EVENT-FRONT-SIDE-LINE-PASS) ; done .
      
    --- behavior of set_side_status( ) in data_frame_rcv_handle
    crl [vote-set-side-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['side-status := 1],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : set-side-status(1) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .

    --- behavior of set_side_info( ) in data_frame_rcv_handle
    crl [vote-set-side-info] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['side-info := V],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : set-side-info(V) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .

    op send-side-info-to-ctrbox : -> Status .
      
    --- the function ctrbox-data defined in ctrbox_comm.c
    eq ctrbox-data(EVENT-FRONT-SIDE-LINE-PASS) = send-side-info-to-ctrbox ; done .

    
    --- behavior of send-side-info-to-ctrbox generated by
    --- function ctrbox-data in data_frame_rcv_handle
    crl [vote-send-side-info-to-ctrbox-succ] :
	< O : Vote | cpu : T, mem : M, pool : P > [==> CON-DES : SOCKET-TYPE-5 | none]
      => < O : Vote | cpu : ideal, pool : enqueue(T', P) >
	[==> CON-DES : DAT-SOC | some data(DATA)]
      if < socket-rcv(S) : Thread | st : send-side-info-to-ctrbox ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > 
	  /\ DATA := SOURCE-VOTE | EVENT-VOTE-SIDE-LINE-PASS-START | M['side-info] | 0 | 0 .
    crl [vote-send-side-info-to-ctrbox-block] :
	< O : Vote | cpu : T, mem : M, pool : P > [==> CON-DES : SOCKET-TYPE-5 | some F]
      => < O : Vote | cpu : ideal, pool : enqueue(T, P) >
	[==> CON-DES : DAT-SOC | some F]
      if < socket-rcv(S) : Thread | st : send-side-info-to-ctrbox ; ST > := T .

      
    --- behavior of rt_handle( ) in data_frame_rcv_handle, and located in rt_handle.c
    crl [vote-rt-handle] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal,
		      mem : M['rt-vote := (rt-core: V , rt-control-status: CONTROL-AUTO )],
		      pool : enqueue(T', P) >
      if < socket-rcv(S) : Thread | st : rt-handle(V) ; ST > := T
	  /\ T' := < socket-rcv(S) : Thread | st : ST > .      

      
    **********************************
    *** behavior of command-frame-rcv-handle
    **********************************

    --- thread command_frame_rcv_handle done
    crl [vote-command-frame-rcv-handle-done] :
	< O : Vote | cpu : T > => < O : Vote | cpu : ideal >
      if < command-frame-rcv-handle : Thread | st : done > := T .

    op set-auto-ack-status : Nat -> Status .
    op set-manual-ack-status : Nat -> Status .
    op handle-event-mannal-to-auto : -> Status .
    op set-to-manual-status : Nat -> Status .
      
    --- command_frame_rcv_handle
    *** events from SOURCE-COM are all omitted
    *** events from SOURCE-CORE are all omitted
    eq handle( SOURCE-CONTROL | EVENT-GEAR8-AUTO-CONFIRM-ACK | V )
      = set-auto-ack-status(1) .
    eq handle( SOURCE-CONTROL | EVENT-TWO-GEAR-TO-MANNUL | V )
      = set-manual-ack-status(1) .
    eq handle( SOURCE-CONTROL | EVENT-MANNAL-TO-AUTO | V )
      = handle-event-mannal-to-auto .
    eq handle( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | V )
      = set-to-manual-status(1) .
    eq handle( S:EventSource | E:EventType | V ) = done [owise] .
    *** DONE for VOTE
    

    --- behavior of set_auto_ack_status( ) in command_frame_rcv_handle
    crl [vote-set-auto-ack-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['auto-ack-status := 1],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-auto-ack-status(1) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .

    --- behavior of set_manual_ack_status( ) in command_frame_rcv_handle
    crl [vote-set-manual-ack-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['manual-ack-status := 1],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-manual-ack-status(1) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .      

    op set-to-auto-gear : Nat -> Status .
    op get-throttle : Memory -> Nat .
    op set-to-auto-status : Nat -> Status .
      
    --- behavior/definition of handle-event-mannal-to-auto in command_frame_rcv_handle
    --- crl [vote-handle-event-mannal-to-auto] :
    ceq < O : Vote | cpu : < command-frame-rcv-handle : Thread | st : ST >,
		     mem : M >
      = < O : Vote | cpu : < command-frame-rcv-handle : Thread | st : ST' > >
      if handle-event-mannal-to-auto := ST
	  /\ ST' := set-to-auto-gear(get-throttle(M)) ; set-to-auto-status(1) .

    eq get-throttle(M) = (M['throttle-gear1]).gear .

    --- behavior of set_to_auto_gear( ) in command_frame_rcv_handle
    crl [vote-set-to-auto-gear] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['to-auto-gear := N],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-to-auto-gear(N) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .

    --- behavior of set_to_auto_status( ) in command_frame_rcv_handle
    crl [vote-set-to-auto-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['to-auto-status := 1],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-to-auto-status(1) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .

    --- behavior of set_to_manual_status( ) in command_frame_rcv_handle
    crl [vote-set-to-manual-status] :
	< O : Vote | cpu : T, mem : M, pool : P >
      => < O : Vote | cpu : ideal, mem : M['to-manual-status := 1],
		      pool : enqueue(T', P) >
      if < command-frame-rcv-handle : Thread | st : set-to-manual-status(1) ; ST > := T
	  /\ T' := < command-frame-rcv-handle : Thread | st : ST > .                  

      
      
      
    *********************************
    *** Testing
    *********************************
    
    op test : Nat -> Configuration .
    eq test(15) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : empty, pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-FRONT-BRANCH-TRANSFER | 33 | 0 | 0 ) ] .
    eq test(16) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 1), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-FRONT-SIDE-LINE-PASS | 33 | 0 | 0 ) ]
	[==> CON-DES : DAT-SOC | none ] .
    eq test(17) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-FRONT-SIDE-LINE-PASS | 33 | 0 | 0 ) ]
	[==> CON-DES : DAT-SOC | none ] .
    eq test(18) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-COM | EVENT-FRONT-SIDE-LINE-PASS | 33 | 0 | 0 ) ]
	[==> CON-DES : DAT-SOC
	  | some data( SOURCE-COM | EVENT-FRONT-BRANCH-TRANSFER | 33 | 0 | 0 ) ] .
    eq test(19) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some data( SOURCE-CORE | EVENT-REAL-TIME-CTRL | 99 | 0 | 0 ) ]
	[==> CON-DES : DAT-SOC | none ] .
    eq test(20) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-GEAR8-AUTO-CONFIRM-ACK | 1 ) ] .
    eq test(21) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : ('side-status -> 0), pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-TWO-GEAR-TO-MANNUL | 1 ) ] .
    eq test(22) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : (('side-status -> 0), ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 ))),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-MANNAL-TO-AUTO | 1 ) ] .
    eq test(23) = < VOTE-DES : Vote | cpu : < socket-rcv(SOCKET-TYPE-1) : Thread | st : read >,
	mem : (('side-status -> 0), ('throttle-gear1 -> (gear: 8 ,auto-or-manual: 0 ))),
	pool : empty >
	[==> VOTE-DES : SOCKET-TYPE-1
	  | some command( SOURCE-CONTROL | EVENT-AUTO-TO-MANNAL | 1 ) ] .            
    

    
endom)

        
(omod LKJ is
    protecting DATA .
    class LKJ | data : Data .
endom)

(omod CTRL-BOX is
    protecting DATA .
    class CtrlBox | data : Data .
endom)
    
(omod SYSTEM is
    protecting SOCKET .
    protecting COMM .
    protecting CORE .
    protecting VOTE .
    protecting LKJ .
    protecting CTRL-BOX .
---    pr QUEUE .
    pr THREADPOOL .

    op mem : -> Memory .
    op pool : -> ThreadPool .




    --- j  
***(    ceq < O:Oid : Board | cpu : C:Object, mem : M:Memory, pool : P:ThreadPool >
      = < O:Oid : Board | cpu : ideal, mem : mem, pool : pool >
      if C:Object =/= ideal /\ M:Memory =/= mem /\ P:ThreadPool =/= pool . )
    
    
    
        
endom)
  
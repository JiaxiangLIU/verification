% This is LLNCS.DOC the documentation file of
% the LaTeX2e class from Springer-Verlag
% for Lecture Notes in Computer Science, version 2.4
\documentclass{llncs}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
%\usepackage{llncsdoc}

\newcommand{\hide}[1]{\ignorespaces}

\begin{document}
%\thispagestyle{empty}
%\begin{flushleft}
%\end{flushleft}

\title{Formal Analysis of Rate-Monotonic Scheduling Implementation via Real-Time Maude}
\author{Jiaxiang Liu\inst{1,2}}
\institute{School of Software, Tsinghua University, Beijing, China
  \and \'Ecole Polytechnique, Palaiseau, France}
\maketitle
\thispagestyle{empty}

\section{Introduction}

\section{Real-Time Maude}

Real-Time Maude is a language and tool that extends Maude to support
the formal specification and analysis of real-time systems.

\subsection{Specification}

A Real-Time Maude module specifies a \emph{real-time rewrite theory}
$(\Sigma, E\cup A , IR, TR)$, where:

\begin{itemize}
\item $\Sigma$ is an algebraic \emph{signature}, that is, a set of
  declarations of \emph{sorts}, \emph{subsorts} and \emph{function
    symbols}.

\item $(\Sigma, E\cup A)$ is a \emph{membership equational logic
  theory}, with $E$ a set of possibly conditional equations, and $A$ a
  set of equational axioms such as associativiy, commutativity and
  identity.  $(\Sigma, E\cup A)$ specifies the system's state space as
  an algebraic data type, and includes a built-in specification of a
  sort \verb|Time|.

\item $IR$ is a set of \emph{labeled conditional rewrite rules}
  specifying the system's local transitions, each of which has the
  form $[l]~:~t\rightarrow t'\mbox{ \textbf{if}
  }\bigwedge^n_{j=1}cond_j$, where each $cond_j$ is an equality
  $u_j=v_j$, and $l$ is a \emph{label}. Such a rule specifies an
  \emph{instantaneous transition} from an instance of $t$ to the
  corresponding instance of $t'$, \emph{provided} the conditions hold.

\item $TR$ is a set of \emph{tick rules} $[l]~:~\{t\}\rightarrow\{t'\}
  \mbox{ \textbf{in time} }\tau\mbox{ \textbf{if} }cond$ that advance
  time in the \emph{entire} state $t$ by $\tau$ time units.
\end{itemize}

A class declaration $\texttt{class }C\texttt{ |
}att_1\texttt{:}s_1\texttt{,}\ldots\texttt{,}att_n\texttt{:}s_n$
declares a class $C$ with attributes $att_1$ to $att_n$ of sorts $s_1$
to $s_n$. An \emph{object} of class $C$ in a given state is
represented as a term $\texttt{< } O\texttt{:} C \texttt{ | }
att_1\texttt{:}val_1\texttt{,} \ldots
\texttt{,}att_n\texttt{:}val_n\texttt{ >}$ of sort \verb|Object|,
where $O$, of sort \verb|Oid|, is the object's \emph{identifier}, and
where $val_1$ to $val_n$ are the current values of the attributes
$att_1$ to $att_n$. A \emph{subclass} inherits all the attributes and
rules of its superclasses.

\subsection{Formal Analysis}
In this paper, we only consider Real-Time Maude's \emph{linear
  temporal logic model checker}, which analyzes whether \emph{each}
behavior satisfies a temporal logic formula. \emph{State propositions}
are terms of sort \verb|Prop|, and their symantics is defined by
equations $\texttt{ceq } statePattern \texttt{ |= } prop \texttt{ = }
b \texttt{ if } cond$, with $b$ a term of sort \verb|Bool|, stating
that $prop$ evaluates to $b$ in states that are instances of
$statePattern$ when the condition $cond$ holds. These equations
together define $prop$ to hold in all states $t$ where $t \texttt{ |=
} prop$ evaluates to \verb|true|. A temporal logic \emph{formula} is
constructed by state propositions and temporal logic operators such as
\verb|True|, \verb|False|, \verb|~|(negation), \verb|/\|, \verb|\/|,
\verb|->|(implication), \verb|[]|(``always''),
\verb|<>|(``eventually'') and \verb|U|(``until''). Real-Time Maude
provides both \emph{unbounded} and \emph{time-bounded} LTL model
checking. The time-bounded model checking command
\begin{alltt}
  (mc \(t\) |=t \(formula\) in time <= \(timeLimit\) .)
\end{alltt}
checks whether the temporal logic formula holds in all behaviors up to
duration $timeLimit$ starting from the initial state $t$.

\section{Rate-Monotonic Scheduling Algorithm and the Implementation}

\subsection{Formulation of the Standard Setting}
The frequently used setting of the RMS algorithm for analysis
considers a task set consisting only of $n$ periodic tasks
$\tau_1,\ldots,\tau_n$. Task $\tau_i$ has a period $T_i$ and a
computation time $C_i$. First jobs of all tasks are assumed to be
instantiated simultaneously. This means that jobs corresponding to
task $\tau_i$ are initiated at times $kT_i, k\ge 0$. Deadlines consist
of runability constraints only, that is, the job initiated at time
$kT_i$ has $(k+1)T_i$ as its deadline, which is the initiation time of
the next job. The RMS algorithm chooses the labeling such that $T_1\le
T_2\le \ldots \le T_n$. Consequently, $\tau_i$ receives priority
$i$. The following assumptions are made:

(A1) Computation time $C_i$ for each task $\tau_i$ is constant and
does not vary with time.

(A2) Tasks are independent, such that they are ready to run at their
initiation times and can be preempted instantly (ignoring all
blocking).

(A3) All overhead, such as task swapping times, is ignored.

In this paper, our application of the RMS algorithm meets the
assumption~(A2), while we would try to relax (A1) and (A3) in our
analysis model.

\subsection{The Implementation of RMS}
The algorithm of the RMS is straightforward, and it is easy to
implement it in pratical systems. However, the way to implement it is
not unique. Our target implementation to analyze is from a realistic
avionic operating system. Interrupts triggered by the clock would come
every $T$, which we call \emph{interrupt cycle}. When an interrupt
request comes, if the system is interruptable, i.e. the interrupt
switch is enabled, the funtion $schedule()$ will be called; otherwise
$schedule()$ will be called once the interrupt switch becomes enable.
The pseudo code of $schedule()$ is shown as
Algorithm~\ref{a:schedule}, where $taskList$ is the list of periodic
tasks, which are needed to be scheduled, and assumed ordered
descendingly by priorities, and where both variables $taskList$ and
$timer$ are global. In this implementation, the period $T_i$ of each
task is a multiple of $T$, and the tasks are independent, meeting the
assumption~(A2).

\begin{algorithm}
  \caption{The C-Like Pseudo Code of $schedule()$}
  \label{a:schedule}
  \begin{algorithmic}[1]
\Function{$schedule$}{$ $}{}
  \State \Call{$int\_o\!f\!\!f$}{$ $}; \Comment{to disable interrupts}
  \State \Call{$updateStatus$}{$taskList$};
  \State $timer = timer + 1$;
  \State $p = taskList$;
  \While{$p$} 
    \If{$p\rightarrow status == \textit{INTERRUPT}$}
      \State \Return;
    \ElsIf{$p\rightarrow status == \textit{READY}$}      
      \State $p\rightarrow status = \textit{RUNNING}$;
      \State \Call{$int\_on$}{$ $}; \Comment{to enable interrupts}
      \State $p\rightarrow function()$; \Comment{to run the task}
      \State \Call{$int\_o\!f\!\!f$}{$ $};
      \State $p\rightarrow status = \textit{DORMANT}$;
    \EndIf
    \State $p = p\rightarrow next$;
  \EndWhile
\EndFunction
\Function{$updateStatus$}{$p$}
  \While{$p$}
    \If{$p\rightarrow status == \textit{RUNNING}$}
      \State $p\rightarrow status = \textit{INTERRUPT}$;
    \EndIf
    \If{$timer~\%~(p\rightarrow period) == 0$} \Comment{the task should be initiated}
      \If{$p\rightarrow status == \textit{DORMANT}$} 
        \State $p\rightarrow status = \textit{READY}$;
      \Else \Comment{the status is \textit{READY} or \textit{INTERRUPT}}
	\State \Call{$reportTaskError$}{$p$}; \Comment{the task misses its deadline}
      \EndIf
    \EndIf
    \State $p = p\rightarrow next$;
  \EndWhile
\EndFunction
  \end{algorithmic}
\end{algorithm}

\section{Formalizing the RMS Implementation}


\section{Formal Analysis}
\subsection{Properties}
\subsection{Completeness of the Analysis}

\section{Related Work}

\section{Conclusion}


\end{document}

% This is LLNCS.DOC the documentation file of
% the LaTeX2e class from Springer-Verlag
% for Lecture Notes in Computer Science, version 2.4
\documentclass{llncs}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumerate}
\usepackage{epic}
\usepackage{pstricks}
%\usepackage{llncsdoc}

\newcommand{\hide}[1]{\ignorespaces}

\begin{document}
%\thispagestyle{empty}
%\begin{flushleft}
%\end{flushleft}

\title{Formal Analysis of Rate-Monotonic Scheduling Implementation via Real-Time Maude}
\author{Jiaxiang Liu\inst{1,2}}
\institute{School of Software, Tsinghua University, Beijing, China
  \and \'Ecole Polytechnique, Palaiseau, France}
\maketitle
\thispagestyle{empty}

\section{Introduction}
Periodic task scheduling is one of the most studied topics within the
field of real-time systems, due to the large number of control systems
that require cyclic activities. A set of periodic tasks is said to be
\emph{schedulable} with respect to some scheduling algorithm if all
jobs meet their deadlines. \emph{Rate-Monotonic Scheduling}
(\emph{RMS}) algorithm is a \emph{fixed} priority scheduling algorithm
for preemptive hard real-time environments proposed by Liu and
Layland~\cite{DBLP:journals/jacm/LiuL73} in 1973, which assigns
priorities to jobs according to the periods of the corresponding
tasks: the smaller the period, the higher the priority. As it is easy
to implement and is proved to be the \emph{optimal} fixed priority
scheduling algorithm~\cite{DBLP:journals/jacm/LiuL73}, in the sense
that any set of tasks that is schedulable under \emph{some} fixed
priority scheduling algorithm is also schedulable with respect to RMS
algorithm, RMS is widely used in different kinds of real-time
applications, some of which are even safety-critical, such as trains,
avionics and so on. 

Liu and Layland also gave a sufficient condition for the
schedulability of a set of $n$ tasks scheduled by RMS algorithm
in~\cite{DBLP:journals/jacm/LiuL73}:
$\displaystyle\Sigma^n_{i=1}C_i/T_i \le n(2^{1/n}-1)$, where $C_i$ and
$T_i$ are the computation time and the period of task $\tau_i$
respectively. Two main directions on RMS have been explored since
then. One is to relax the assumptions on the original RMS model, for
instance, to allow aperiodic
tasks~\cite{DBLP:conf/rtss/LehoczkySS87,DBLP:journals/rts/SpruntSL89,DBLP:conf/rtss/LehoczkyR92,DBLP:journals/tc/StrosniderLS95},
to generalize it to be
\emph{deadline-monotonic}~\cite{DBLP:journals/pe/LeungW82,audsley1993deadline},
to allow resource sharing among tasks~\cite{DBLP:journals/tc/ShaRL90},
to extend it on
multiprocessors~\cite{dhall1978real,DBLP:journals/rts/LopezGDG03,DBLP:journals/tpds/LopezDG04,DBLP:journals/tc/BaruahG03},
to enhance
fault-tolerance~\cite{DBLP:journals/rts/OhS94,DBLP:journals/rts/GhoshMMS98,DBLP:journals/tpds/BertossiMR99}
and so on, making RMS algorithm applicable on more systems. The other
direction is to generate better schedulablity test conditions for the
algorithm and its
extensions~\cite{DBLP:conf/rtss/LehoczkySD89,DBLP:conf/rtss/KuoM91,DBLP:journals/tc/BiniBB03,DBLP:journals/rts/LopezGDG03,DBLP:journals/tc/BaruahG03,gardner1999}. The
RMS algorithm is of such practical importance that we certainly cannot
exhaust all the results in the literature here.

On the other hand, an increasing number of efforts to apply formal
methods, such as model checking and theorem proving, are made to
analyze safety-critical systems for the past few
years~\cite{DBLP:journals/iandc/MeseguerR13,DBLP:journals/cacm/Leroy09,DBLP:conf/sosp/KleinEHACDEEKNSTW09}. However,
as far as we know, few~\cite{DBLP:conf/iceccs/CuiDT14,TianD2011} are
made to analyze the RMS algorithm, none for implementations of RMS.

In this paper, we use \emph{Real-Time Maude}, a \emph{rewriting}-based
modeling language and analyzing tool for real-time systems, to model a
realistic implementation of RMS algorithm and then verify some desired
properties on the built model. The model we built based on the
realistic implementation extends the original ideal one proposed
in~\cite{DBLP:journals/jacm/LiuL73}, by allowing computation time of
tasks to be non-constant, and by considering overheads and other
realistic aspects.

The rest of this paper is organized as follows: Section~\ref{s:rms}
introduces the standard setting of the RMS algorithm proposed
in~\cite{DBLP:journals/jacm/LiuL73} and our considering realistic
implementation. Section~\ref{s:rtmaude} gives a background to
Real-Time Maude. Section~\ref{s:formalism} presents how we model the
RMS implementation using Real-Time Maude. Then
Section~\ref{s:verification} explains how to verify the desired
properties and to analyze the results. Related work is discussed in
Section~\ref{s:relate} before concluding in
Section~\ref{s:conclusion}.


\section{Rate-Monotonic Scheduling Algorithm and the Implementation}
\label{s:rms}
\subsection{Formulation of the Standard Setting}
The frequently used setting of the RMS algorithm for analysis
considers a task set consisting only of $n$ periodic tasks
$\tau_1,\ldots,\tau_n$. Task $\tau_i$ has a period $T_i$ and a
computation time $C_i$. First jobs of all tasks are assumed to be
instantiated simultaneously. This means that jobs corresponding to
task $\tau_i$ are initiated at times $kT_i, k\ge 0$. Deadlines consist
of runability constraints only, that is, the job initiated at time
$kT_i$ has $(k+1)T_i$ as its deadline, which is the initiation time of
the next job. The RMS algorithm chooses the labeling such that $T_1\le
T_2\le \ldots \le T_n$. Consequently, $\tau_i$ receives priority
$i$. The following assumptions are made:

(A1) Computation time $C_i$ for each task $\tau_i$ is constant and
does not vary with time.

(A2) Tasks are independent, such that they are ready to run at their
initiation times and can be preempted instantly (ignoring all
blocking).

(A3) All overhead, such as task switching times, is ignored.

In this paper, we consider an implementation instead of the RMS
algorithm itself, thus the model would be more complicated than this
ideal formulation.  Assumptions~(A1) and (A3) will be relaxed to shape a more
realisitc analysis model, as shown below.

\subsection{The Implementation of RMS}
The algorithm of the RMS is straightforward, and it is easy to
implement it in pratical systems. However, the way to implement it is
not unique. Our target implementation to analyze is part of a
realistic avionic operating system from our industrial
partner. Interrupts triggered by the clock would come every $T$, which
we call \emph{interrupt cycle}. When an interrupt request comes, if
the system is interruptable, i.e. the interrupt mask is cleared, the
function $schedule()$ will be called; otherwise the handler function
$schedule()$ will be pending until the interrupt mask becomes cleared.
The pseudocode of $schedule()$ is shown as Algorithm~\ref{a:schedule},
where $taskList$ is the list of periodic tasks, which are needed to be
scheduled, and assumed ordered descendingly by priorities, and where
both variables $taskList$ and $timer$ are global. In this
implementation, there is only one kind of interrupt, the period $T_i$
of each task is a multiple of $T$, and the tasks are independent,
meeting assumption~(A2).

\begin{algorithm}
  \caption{The C-Like Pseudocode of $schedule()$}
  \label{a:schedule}
  \begin{algorithmic}[1]
\Function{$schedule$}{$ $}{}
  \State \Call{$int\_o\!f\!\!f$}{$ $}; \Comment{to disable interrupts}
  \State \Call{$updateStatus$}{$taskList$}; \label{l:updatestatus}
  \State $timer = timer + 1$; \label{l:timer} \label{l:inc}
  \State $p = taskList$;
  \While{$p$} \label{l:startrun1st}
    \If{$p\rightarrow status == \textit{INTERRUPT}$}
      \State \Return;
    \ElsIf{$p\rightarrow status == \textit{READY}$}      
      \State $p\rightarrow status = \textit{RUNNING}$;
      \State \Call{$int\_on$}{$ $}; \Comment{to enable interrupts} \label{l:endrun1st}
      \State $p\rightarrow function()$; \Comment{to run the task} \label{l:function}
      \State \Call{$int\_o\!f\!\!f$}{$ $};
      \State $p\rightarrow status = \textit{DORMANT}$;
    \EndIf
    \State $p = p\rightarrow next$;
  \EndWhile
\EndFunction
\Function{$updateStatus$}{$p$}
  \While{$p$}
    \If{$p\rightarrow status == \textit{RUNNING}$} \label{l:startupdate}
      \State $p\rightarrow status = \textit{INTERRUPT}$;
    \EndIf
    \If{$timer~\%~(p\rightarrow period) == 0$} \Comment{the task should be initiated}
      \If{$p\rightarrow status == \textit{DORMANT}$} 
        \State $p\rightarrow status = \textit{READY}$;
      \Else \Comment{the status is \textit{READY} or \textit{INTERRUPT}}
	\State \Call{$reportTaskError$}{$p$}; \Comment{the task misses its deadline}
      \EndIf
    \EndIf \label{l:endupdate}
    \State $p = p\rightarrow next$;
  \EndWhile
\EndFunction
  \end{algorithmic}
\end{algorithm}

The function $updateStatus()$ updates status of all tasks in the list:
if the task is running when the interrupt is handled, it becomes
interrupted\footnote{Note that the status \textit{INTERRUPT} indicates
  the task is interrupted for the moment, or was interrupted before
  but is not finished running yet.}; the task, which is at its
initiated time, would be set to be ready if its previous corresponding
job is finished, or produce an error otherwise. Notice that
$schedule()$ is called only when the periodic interrupt is handled. It
can be also interrupted while running some task (Line~\ref{l:function}
in Algorithm~\ref{a:schedule}), such that the running of $schedule()$
can be nested.

\section{Real-Time Maude}
\label{s:rtmaude}
Real-Time Maude is a language and tool that extends Maude to support
the formal specification and analysis of real-time systems.

\subsection{Specification}
A Real-Time Maude module specifies a \emph{real-time rewrite theory}
${\cal R} = (\Sigma, E\cup A , IR, TR)$, where:
\begin{itemize}
\item $\Sigma$ is an algebraic \emph{signature}, that is, a set of
  declarations of \emph{sorts}, \emph{subsorts} and \emph{function
    symbols}.
\item $(\Sigma, E\cup A)$ is a \emph{membership equational logic
  theory}, with $E$ a set of possibly conditional equations, and $A$ a
  set of equational axioms such as associativiy, commutativity and
  identity.  $(\Sigma, E\cup A)$ specifies the system's state space as
  an algebraic data type, and includes a built-in specification of a
  sort \verb|Time|.
\item $IR$ is a set of \emph{labeled conditional rewrite rules}
  specifying the system's local transitions, each of which has the
  form $[l]~:~t\rightarrow t'\mbox{ \textbf{if}
  }\bigwedge^n_{j=1}cond_j$, where each $cond_j$ is an equality
  $u_j=v_j$, and $l$ is a \emph{label}. Such a rule specifies an
  \emph{instaneous transition} from an instance of $t$ to the
  corresponding instance of $t'$, \emph{provided} the conditions hold.
\item $TR$ is a set of \emph{tick rules} $[l]~:~\{t\}\rightarrow\{t'\}
  \mbox{ \textbf{in time} }\tau\mbox{ \textbf{if} }cond$ that advance
  time in the \emph{entire} state $t$ by $\tau$ time units.
\end{itemize}

A class declaration $\texttt{class }C\texttt{ |
}att_1\texttt{:}s_1\texttt{,}\ldots\texttt{,}att_n\texttt{:}s_n$
declares a class $C$ with attributes $att_1$ to $att_n$ of sorts $s_1$
to $s_n$. An \emph{object} of class $C$ in a given state is
represented as a term $\texttt{< } O\texttt{:} C \texttt{ | }
att_1\texttt{:}val_1\texttt{,} \ldots
\texttt{,}att_n\texttt{:}val_n\texttt{ >}$ of sort \verb|Object|,
where $O$, of sort \verb|Oid|, is the object's \emph{identifier}, and
where $val_1$ to $val_n$ are the current values of the attributes
$att_1$ to $att_n$. A \emph{subclass} inherits all the attributes and
rules of its superclasses.

\subsection{Formal Analysis}
In this paper, we only consider Real-Time Maude's \emph{linear
  temporal logic model checker}, which analyzes whether \emph{each}
behavior satisfies a temporal logic formula. \emph{State propositions}
are terms of sort \verb|Prop|, and their symantics is defined by
equations $\texttt{ceq } statePattern \texttt{ |= } prop \texttt{ = }
b \texttt{ if } cond$, with $b$ a term of sort \verb|Bool|, stating
that $prop$ evaluates to $b$ in states that are instances of
$statePattern$ when the condition $cond$ holds. These equations
together define $prop$ to hold in all states $t$ where $t \texttt{ |=
} prop$ evaluates to \verb|true|. A temporal logic \emph{formula} is
constructed by state propositions and temporal logic operators such as
\verb|True|, \verb|False|, \verb|~|(negation), \verb|/\|, \verb|\/|,
\verb|->|(implication), \verb|[]|(``always''),
\verb|<>|(``eventually'') and \verb|U|(``until''). Real-Time Maude
provides both \emph{unbounded} and \emph{time-bounded} LTL model
checking. The time-bounded model checking command
\begin{alltt}
  (mc \(t\) |=t \(formula\) in time <= \(timeLimit\) .)
\end{alltt}
checks whether the temporal logic formula holds in all behaviors up to
duration $timeLimit$ starting from the initial state $t$.

\section{Formalizing the RMS Implementation}
\label{s:formalism}
Based on the code, we model the implementation under the following
assumptions:

(A1') Computation time $C_i$ for each task $\tau_i$ is not constant,
varying randomly between minimum $C^{min}_i$ and maximum $C^{max}_i$.

(A2) Tasks are independent, such that they are ready to run at their
initiation times and can be preempted instanly.

(A3') The times for scheduling and task switching should be
considered, while other overhead is ignored.

These assumptions make our model different with the standard
formulation. For instance, due to the interrupt masking and
consideration of scheduling overhead, jobs corresponding to task
$\tau_i$ could not be initiated at exactly $kT_i$, but a bit later.
Note that (A2) says jobs are ready to run at their initiation times,
however, they cannot run at their initiation times, because scheduling
takes time.

\subsection{Some Basic Data Types}
In our model, tasks are identified with their indexes of sort
\verb|Nat| in the $taskList$. We define a sort \verb|MaybeNat|
wrapping \verb|Nat|s to refer to some task, with \emph{constructor}
\verb|some| followed by a \verb|Nat| $n$ indicating the task with
index $n$, and \verb|none| for no task:
\begin{verbatim}
  op none : -> MaybeNat [ctor] .
  op some_ : Nat -> MaybeNat [ctor] .
\end{verbatim}

A sort \verb|Stack| is introduced to simulate the stack of the system,
storing the tasks that are being interrupted, and equipped with
operations \verb|push|, \verb|pop| and \verb|peek| on it.
\begin{verbatim}
  op bottom : -> Stack [ctor] .
  op _#_ : Nat Stack -> Stack [ctor] .
\end{verbatim}

We also need a sort \verb|Interval| denoting the interval, within
which the computation time of a task varies and which we call
\emph{possible finishing interval}, and a sort \verb|Counter| to
represent the time some task has been running and the corresponding
possible finishing interval.
\begin{verbatim}
  op [_,_] : Time Time -> Interval [ctor] .
  op [_/_] : Time Interval -> Counter [ctor] .
\end{verbatim}

At last, to make our model checkable by \emph{untimed model-checking},
it is reasonable to reset the global variable $timer$ when it reaches
an upperbound while increasing (see Line~\ref{l:timer} in
Algorithm~\ref{a:schedule}) in the model. Then $timer$ is of sort
\verb|Timer| and the upperbound would be the least common multiple of
the periods of all tasks.
\begin{verbatim}
  op [_/_] : Nat NzNat -> Timer [ctor] .
\end{verbatim}

\subsection{Modeling the System States}
Abstracting from some details, the running system could be considered
as consisting of several parts: the tasks which are scheduled, the
scheduler itself, the hardware including registers and stacks, and the
interrupt source. The scheduler, i.e. the function $schedule()$, has
only the variable $timer$ to be interesting, thus it can be described
by a single variable. We will present the modeling of the other parts
one by one.

\subsubsection{Tasks}
In this paper, since we are trying to analyze the implementation of
the scheduler, each task will be abstracted from its functionality and
treated as a \verb|Counter|. As mentioned above, times for scheduling
and task switching will be also considered in the model. They are just
seen as two system tasks. Every task is modeled as an object instance
of some subclass of the base class \verb|Task|:
\begin{verbatim}
  class Task | cnt : Counter .
  op error : -> Object [ctor] .
\end{verbatim}
The attribute \verb|cnt| denotes the computation time of the task,
while \verb|error| is an object indicating some task which misses its
deadline.

A periodic task, which is needed to be scheduled, is an object
instance of the subclass \verb|PTask| with additional attributes
\verb|priority|, \verb|period| and \verb|status|:
\begin{verbatim}
  class PTask | priority : Nat, period : NzNat, status : Status .
  subclass PTask < Task .
\end{verbatim}
where \verb|Status| is a sort with four constant constructors, just as
in the implementation:
\begin{verbatim}
  ops RUNNING INTERRUPT READY DORMANT : -> Status [ctor] .
\end{verbatim}
The list of periodic tasks, the variable $taskList$ in the
implementation, is modeled as an instance of the sort \verb|TaskList|,
which is a list of \verb|PTask|s\footnote{Following the Maude
  convention, variables would be written in capital letters.}:
\begin{verbatim}
  op null : -> TaskList [ctor] .
  op _::_ : Object TaskList ~> TaskList [ctor] .
  mb (< O:Oid : PTask |> :: L:TaskList) : TaskList .
  mb (error :: L:TaskList) : TaskList .
\end{verbatim}
As mentioned already, periodic tasks would be identified by their
indexes in the list.

On the other hand, a system task is an object instance of the subclass
\verb|SysTask| of \verb|Task| with no extra attributes:
\begin{verbatim}
  class SysTask .            subclass SysTask < Task .
\end{verbatim}
Different from periodic tasks, system tasks would be organized in a
multiset of sort \verb|SysTasks|, and identified by their \verb|Oid|s.
We abstract here from the detailed definitions thanks to the
similarity.

\subsubsection{Hardware} Our model considers two parts of hardware relating
to the interrupt handling inside the system, the registers and the
stack.

The set of registers is modeled as an object instance of the class
\verb|Regs|, with attributes \verb|pc| denoting the program counter,
\verb|mask| for the interrupt masking flag and \verb|ir| for the
interrupt request flag.
\begin{verbatim}
  class Regs | pc : TaskID, mask : Bool, ir : Bool .
\end{verbatim}
where the sort \verb|TaskID| is a supersort of \verb|MaybeNat| and
\verb|Oid|, referring to some task.
\begin{verbatim}
  subsorts MaybeNat Oid < TaskID .
\end{verbatim}

Some operations, such as \verb|getPc|, \verb|setMask| and so on, are
also defined on the class \verb|Regs|.

Then the hardware is naturally described by the sort \verb|Hardware|:
\begin{verbatim}
  op [_;_] : Object Stack ~> Hardware [ctor] .
  mb ([ < O:Oid : Regs |> ; S:Stack ]) : Hardware .
\end{verbatim}

\subsubsection{Interrupt Source}
The interrupt source is modeled in our model as an object of class \verb|IntSrc|,
with attribute \verb|cycle| denoting the interrupt cycle:
\begin{verbatim}
  class IntSrc | val : Time, cycle : Time .
\end{verbatim}

\subsubsection{System}
The system in the model is just a composition of the parts introduced
above, with a sort \verb|System|\footnote{Some variable declarations
  are not shown for simplicity.}:
\begin{verbatim}
  op _____ : 
       TaskList Timer SysTasks Hardware Object ~> System [ctor] .
  mb (L T STS HW < O:Oid : IntSrc |>) : System .
\end{verbatim}

\subsection{Interrupt Requesting}
Interrupt requests are performed by the source exactly every cycle
$T$, when the attribute \verb|val| decreases to \verb|zero| while time
advances. This is modeled by the following instaneous conditional rule
applied on \verb|System|:
\begin{verbatim}
  crl [interrupt-request] :
    (L T STS HW ISRC) => (L T STS (HW).intReq reset(ISRC))
    if (ISRC).timeout .
\end{verbatim}
where the operator \verb|_.timeout| examines whether the attribute
\verb|val| equals to \verb|zero|, and \verb|_.intReq| sets the
\verb|ir| flag indicating there is an interrupt request to be handled:
\begin{verbatim}
  op _.intReq : Hardware -> Hardware .
  eq [ REGS ; S ].intReq = [ (REGS).setIr ; S ] .
\end{verbatim}
Then the request will wait to be handled, which is explained in
Section~\ref{ss:inthandling}.


\subsection{Task Initiation}
Periodic tasks are initiated sequently by exactly the function
$updateStatus()$ in Algorithm~\ref{a:schedule}, which is modeled by
the recursive operation as below:
\begin{verbatim}
  op updateStatus_with_ : TaskList Timer -> TaskList . 
  eq updateStatus null with TIMER = null .
  eq updateStatus (TASK :: L) with TIMER
       = (update TASK with TIMER) :: (updateStatus L with TIMER) .
\end{verbatim}
with \verb|TIMER| the current value of the global variable $timer$,
and \verb|update_with_| updating the status of individual task
(Lines~\ref{l:startupdate}-\ref{l:endupdate} in
Algorithm~\ref{a:schedule})
\begin{verbatim}
  op update_with_ : Object Timer ~> Object .
  ceq update < O : PTask | period : T, status : ST > with TIMER
        = if ST == DORMANT then < O : PTask | status : READY >
          else error fi
      if TIMER rem T == 0 .
  eq update < O : PTask | status : ST > with TIMER
       = if ST == RUNNING then < O : PTask | status : INTERRUPT >
         else < O : PTask |> fi [owise] .
\end{verbatim}
In the case where \verb|TIMER|($timer$) can be divided by the task's
period, i.e. the task should be initiated, if the status is
\verb|DORMANT|, it should be ready to run; otherwise it means the
previous job of the task is not finished, thus it misses its deadline,
producing an \verb|error|. In the other case where the tasks should
not be initiated, the status of the task changes only if it is
\verb|RUNNING|. We can easily see \verb|updateStatus_with_| behaves
the same as $updateStatus()$.

\subsection{Interrupt Handling and Task Scheduling}
\label{ss:inthandling}
When an interrupt request comes, it may not be ``seen'' immediately by
the system. It requires the \verb|mask| flag to be cleared. Once the
request is seen, it is handled by performing two stages: the interrupt
mechanism of the hardware (such as clearing \verb|ir|, pushing context
into stack and so on) and running the $schedule()$ function. This is
modeled by the following instaneous rewrite rule:
\begin{verbatim}
  crl [interrupt-handle] :
    SYSTEM => ((SYSTEM).interrupt).startScheduling
    if (SYSTEM).existInt .
\end{verbatim}
where \verb|_.existInt| checks whether \verb|mask| is cleared
\emph{and} \verb|ir| is set. The operation \verb|_.interrupt| models
the interrupt mechanism performed by the hardware and does four
things: (i)clearing the \verb|ir| flag, which means the request has
been handled; (ii)pushing the current \verb|pc| value into the stack,
storing the interrupted context; (iii)assigning \verb|scheduling| of
sort \verb|Oid| to \verb|pc|, which indicates that $schedule()$ is
running; and (iv)setting the \verb|mask| flag, to mask the coming
interrupt requests. As for \verb|_.startScheduling|, it performs
updating the status of $taskList$ and increasing $timer$ by $1$,
corresponding to Line~\ref{l:updatestatus} and \ref{l:inc} in
Algorithm~\ref{a:schedule}.
\begin{verbatim}
  op _.startScheduling : System -> System .
  eq (L T STS HW ISRC).startScheduling 
       = ((updateStatus L with T) inc(T) STS HW ISRC) .
\end{verbatim}

It is worth pointing out here that \emph{scheduling} in our model does
not refer to the stage in which $schedule()$ is running. We use it to
refer to, for simplicity, the stage scheduling the first should-be-run
periodic task, i.e.  the code strictly before Line~\ref{l:function} in
Algorithm~\ref{a:schedule}. Therefore,
\begin{definition}
  The \emph{scheduling time} talked about in this paper consists of
  the time for switching from a running task to the function
  $schedule()$ when handling interrupts, the time spent by
  $schedule()$ finding and setting the \emph{first} should-be-run
  periodic task, and the time for switching from $schedule()$ to that
  first should-be-run task.
\end{definition}
Similarly, \emph{switching} in our model refers to the stage finding
out the next should-be-run periodic task when one is finished.
\begin{definition}
  The \emph{switching time} in this paper consists of the time for
  switching from a finished task back into $schedule()$, the time
  spent by $schedule()$ finding and setting the \emph{next}
  should-be-run periodic task, and the time for switching from
  $schedule()$ to that next should-be-run task.
\end{definition}

With our terminology, when the running time of the system task
\verb|scheduling| reaches its possible finishing interval, the
following rule may apply to finish the scheduling stage:
\begin{verbatim}
  crl [scheduling-finish] :
    (L T STS HW ISRC) => (SYSTEM).finishScheduling
    if SYSTEM := (L T STS HW ISRC) 
       /\ (SYSTEM).running == scheduling 
       /\ scheduling mayFinish?in STS .
\end{verbatim}
where operation \verb|_.running| returns the current \verb|pc| value
of the system and \verb|_mayFinish?in_| checks if the running time of
the task reaches its possible finishing interval:
\begin{verbatim}
  op _mayFinish?in_ : Oid SysTasks ~> Bool .
  eq O mayFinish?in [ < O : SysTask | cnt : C > REST ] 
       = C mayFinish? .
  op _mayFinish? : Counter -> Bool .
  eq [ R / [ MIN , MAX ] ] mayFinish?
       = if R lt MIN then false else true fi .
\end{verbatim}
And the operation \verb|_.finishScheduling| performs the remaining
instructions, which are left by \verb|_.startScheduling|, in the
scheduling stage: finding the first should-be-run periodic task and
setting it to run (Line~\ref{l:startrun1st}-\ref{l:endrun1st} in
Algorithm~\ref{a:schedule}).
\begin{verbatim}
  op _.finishScheduling : System -> System .
  eq (L T STS HW ISRC).finishScheduling
       = (L T (finish scheduling in STS) HW ISRC).run1stTask .
\end{verbatim}
where \verb|finish_in_| resets the counter of task \verb|scheduling|,
and \verb|_.run1stTask| models
Line~\ref{l:startrun1st}-\ref{l:endrun1st} in
Algorithm~\ref{a:schedule}, searching the task with highest priority
that has status \verb|INTERRUPT| or \verb|READY| then performing an
\emph{interrupt return} or letting it run respectively.

Similar to \verb|scheduling|, the \verb|switching| stage starts when
the running time of the current running periodic task reaches its
possible finishing interval and finishes when its own running time
does so, with the two following similar rules:
\begin{verbatim}
  crl [task-finish] :
    (L T STS HW ISRC) => (SYSTEM).startSwitching
    if SYSTEM := (L T STS HW ISRC)
       /\ some N := (SYSTEM).running
       /\ some N mayFinish?in L .
  crl [switching-finish] :
    (L T STS HW ISRC) => (SYSTEM).finishSwitching
    if SYSTEM := (L T STS HW ISRC)
       /\ (SYSTEM).running == switching
       /\ switching mayFinish?in STS .
\end{verbatim}

\subsection{Timed Behaviours of the System}
\emph{Timed behaviours} of the system consist of two parts, the
running of tasks, including both periodic ones and system ones, and
the running of interrupt source. These are all modeled as the
following one conventional tick rule:
\begin{verbatim}
  crl [tick]:
    {SYSTEM} => {delta(SYSTEM, R)} in time R 
    if R le mte(SYSTEM) [nonexec] .
\end{verbatim}
where \verb|delta| defines the effects of time elapse on the system,
and \verb|mte| denotes the maximum amount of time allowed to elapse
from the current state until an instaneous transition \emph{must} be
performed. Notice that the variable $R$ is \emph{continuous} with
respect to the specific time domain\footnote{Real-Time Maude contains
  built-in modules to define the time domain to be natural numbers and
  rational numbers, specifying \emph{discrete} time domains and
  \emph{dense} time domains respectively.}  that we choose to
instantiate the model on, which is different from timed automata that
discretize dense time by defining ``clock region''.

Time affects the system by advancing both the running task, whose $ID$
is loaded at \verb|pc|, and the interrupt source simultaneously,
increasing their \verb|cnt| and \verb|val| respectively:
\begin{verbatim}
  ceq delta((L T STS HW ISRC), R)
        = ((deltaTask(ID, L, R) T STS HW (deltaIS(ISRC, R)))
      if ID := (HW).getPc /\ ID :: MaybeNat .
\end{verbatim}
We ease the reading by not showing the case where $ID$ is of sort
\verb|Oid|, due to similarity. At that case, \verb|deltaTask| applies
on \verb|STS| instead of \verb|L|.

The maximum amount of time allowed to elapse depends on three aspects:
the time remained to finish the running task, either periodic one or
system one, the time remained to request an interrupt, and whether or
not there exists a non-masked interrupt request for the moment:
\begin{verbatim}
  ceq mte(L T STS HW ISRC)
        = minimum( mteTask(ID, L),
                   minimum( mteIS(ISRC), mteIr(HW)))
      if ID := (HW).getPc /\ ID :: MaybeNat .
\end{verbatim}
where \verb|mteIr| will return \verb|zero| if there exists a
non-masked interrupt request in the system, or \verb|INF| which
represents \emph{infinity} otherwise. Again we do not show the case
where $ID$ is of sort \verb|Oid|, which is very similar. We should
point out that \verb|mteTask| computes the time remained to reach the
maximum of the possible finishing interval of the task, since it is
the time until which a ``finish'' transition \emph{must} happen.

\section{Formal Verification}
\label{s:verification}
Although Real-Time Maude provides many useful commands and tools to
analyze a model, such as, \verb|rewrite| to execute the model,
\verb|search| to search some reachable state(s) satisfying given
properties from the initial state, the Maude Inductive Theorem Prover
(ITP) to interactively prove properties written in \emph{membership
  equational logic}, and so on, we concentrate in this paper on using
the model checking tool to verify the desired properties of our model.

In this section, we analyze our model of the RMS implementation under
several different scenarios, including both realistic and experimental
ones. Notice that from any (reasonable) given initial state, the
number of reachable states is finite, thanks to the upperbound given
to the $timer$, which provides the potential for applying the untimed
model-checker.

\subsection{Properties Verified}
The main objective is to verify the schedulability of a given set of
periodic tasks. Therefore we define an atomic proposition
\verb|taskTimeout| to hold if there exists an \verb|error| appearing
in the $taskList$ of the current state:
\begin{verbatim}
  op taskTimeout : -> Prop [ctor] .
  eq {L T STS HW ISRC} |= taskTimeout = containError(L) .
\end{verbatim}
where \verb|containError| returns \verb|true| if there is an object
\verb|error| existing in $L$. Then our desired
property--schedulability--can be formalized as the temporal logic
formula \verb|[](~taskTimeout)|. As the property is not
\emph{clocked}, given an initial state \verb|init|, the following
untimed model-checking command returns \verb|true| if our desired
schedulability property holds \emph{with no time limit}; otherwise 
a trace showing a counterexample is provided.
\begin{verbatim}
  (mc init |=u [](~taskTimeout) .)
\end{verbatim}

The other objective is to verify the correctness of the
implementation, in the sense that the periodic tasks are scheduled
exactly with respect to their priorities. The atomic proposition
\verb|scheduleCorrectly| is defined to hold if the running periodic
task is the one requested to be run and with the highest priority:
\begin{verbatim}
  op scheduleCorrectly : -> Prop [ctor] .
  ceq {L T STS HW ISRC} |= scheduleCorrectly 
        = (not containError(L))
          and (if ID :: MaybeNat then shouldRun(ID, L)
               else true fi)
      if ID := (HW).getPc .
\end{verbatim}
where \verb|shouldRun(ID, L)| returns \verb|true| if the task
identified by \verb|ID|, probably \verb|none|, is the one possessing
the highest priority among those whose status is \verb|READY|,
\verb|RUNNING| or \verb|INTERRUPT|. Note that \verb|scheduleCorrectly|
requires no \verb|error| popping up, since our defined correctness
property makes no sense in the implementation once some task misses
its deadline. The correctness property is formalized as the temporal
logic formula \verb|[]scheduleCorrectly|, and can be verified by the
following untimed model-checking command provided an initial state
\verb|init|, which returning \verb|true| indicates the correctness
property holds with no time limit.
\begin{verbatim}
  (mc init |=u []scheduleCorrectly .)
\end{verbatim}

\subsection{Scenarios}
\label{ss:results}
We use the following setting for our verification, which is from the 
statistics provided by our industrial partner:
\begin{itemize}
\item The interrupt cycle is $5ms$.
\item The scheduling time ranges from $5{\mu}s$ to $9{\mu}s$, and the
switching time ranges from $2{\mu}s$ to $4{\mu}s$.
\item The initial state is with empty stack, empty \verb|pc|, cleared 
\verb|mask| and cleared \verb|ir|.
\end{itemize}

We have analyzed our model/implementation in ten different scenarios,
including both realistic ones provided by our industrial partner and
experimental ones designed by ourselves, four of them are described
below:
\begin{itemize}
\item Scenario (i) with two tasks: one having period $5ms$ and
  possible finishing interval $[2.4ms, 3ms]$, and the other having
  period $25ms$ and possible finishing interval $[6.1ms, 7ms]$.
\item Scenario (ii) with two tasks: one having period $5ms$ and
  possible finishing interval $[1.8ms, 2ms]$, and the other having
  period $25ms$ and possible finishing interval $[2.1ms, 2.3ms]$.
\item Scenario (iii) with three tasks: the first having period $5ms$
  and possible finishing interval $[2.5ms, 2.7ms]$, the second having
  period $10ms$ and possible finishing interval $[1.5ms, 2ms]$, and
  the third having period $25ms$ and possible finishing interval
  $[2.6ms, 3ms]$.
\item Scenario (iv) with three tasks: the first having period $5ms$
  and possible finishing interval $[2.2ms, 2.5ms]$, the second having
  period $10ms$ and possible finishing interval $[1.4ms, 1.5ms]$, and
  the third having period $15ms$ and possible finishing interval
  $[4.3ms, 4.5ms]$.
\end{itemize}

Instantiating our model on dense time domain and choosing the
\emph{maximal time sampling strategy}, the results of the model
checking show that both the schedulability and the correctness
properties hold in Scenarios (i-iii), but not in Scenario (iv). For
Scenario (iv), one counterexample of the schedulability is pictured in
Figure~\ref{f:counterexample}, where the third task (task$2$) misses
its deadline at the time $15ms$ that is marked by the tiny red
triangle. And the correctness fails in Scenario (iv) because of the
failure of schedulability.

\begin{figure}[h]
\begin{center}
\begin{picture}(300,110)(0,-10)
\thicklines
\put(0,0){\vector(1,0){320}}
\put(305,5){time(${\mu}s$)}
\thinlines
\put(0,0){\line(0,1){110}}
\put(-25,97){task$0$}
\put(-25,77){task$1$}
\put(-25,57){task$2$}
\put(-44,37){scheduling}
\put(-40,17){switching}
\put(-2,-8){$0$}

\dashline[30]{3}(0,100)(250,100)
\dashline[30]{3}(0,80)(280,80)
\dashline[30]{3}(0,60)(300,60)
\dashline[30]{3}(0,40)(210,40)
\dashline[30]{3}(0,20)(285,20)


\dashline[30]{3}(10,-10)(10,100)
\thicklines
\textcolor{red}{\put(0,40){\line(1,0){10}}}
\put(8,-18){$9$}

\thinlines
\dashline[30]{3}(50,0)(50,100)
\thicklines
\textcolor{blue}{\put(10,100){\line(1,0){40}}}
\put(35,-8){$2509$}

\thinlines
\dashline[30]{3}(55,-10)(55,80)
\thicklines
\textcolor{red}{\put(50,20){\line(1,0){5}}}
\put(46,-18){$2513$}

\thinlines
\dashline[30]{3}(80,0)(80,80)
\thicklines
\textcolor{blue}{\put(55,80){\line(1,0){25}}}
\put(65,-8){$4013$}

\thinlines
\dashline[30]{3}(85,-10)(85,60)
\thicklines
\textcolor{red}{\put(80,20){\line(1,0){5}}}
\put(76,-18){$4017$}

\thinlines
\dashline[30]{3}(100,0)(100,60)
\thicklines
\textcolor{blue}{\put(85,60){\line(1,0){15}}}
\put(90,-8){$5000$}

\thinlines
\dashline[30]{3}(110,-10)(110,100)
\thicklines
\textcolor{red}{\put(100,40){\line(1,0){10}}}
\put(101,-18){$5009$}

\thinlines
\dashline[30]{3}(150,0)(150,100)
\thicklines
\textcolor{blue}{\put(110,100){\line(1,0){40}}}
\put(135,-8){$7509$}

\thinlines
\dashline[30]{3}(155,-10)(155,60)
\thicklines
\textcolor{red}{\put(150,20){\line(1,0){5}}}
\put(146,-18){$7513$}

\thinlines
\dashline[30]{3}(200,0)(200,60)
\thicklines
\textcolor{blue}{\put(155,60){\line(1,0){45}}}
\put(185,-8){$10000$}

\thinlines
\dashline[30]{3}(210,-10)(210,100)
\thicklines
\textcolor{red}{\put(200,40){\line(1,0){10}}}
\put(198,-18){$10009$}

\thinlines
\dashline[30]{3}(250,0)(250,100)
\thicklines
\textcolor{blue}{\put(210,100){\line(1,0){40}}}
\put(230,-8){$12509$}

\thinlines
\dashline[30]{3}(255,-10)(255,80)
\thicklines
\textcolor{red}{\put(250,20){\line(1,0){5}}}
\put(243,-18){$12513$}

\thinlines
\dashline[30]{3}(280,0)(280,80)
\thicklines
\textcolor{blue}{\put(255,80){\line(1,0){25}}}
\put(260,-8){$14013$}

\thinlines
\dashline[30]{3}(285,-10)(285,60)
\thicklines
\textcolor{red}{\put(280,20){\line(1,0){5}}}
\put(272,-18){$14017$}

\thinlines
\dashline[30]{3}(300,0)(300,60)
\thicklines
\textcolor{blue}{\put(285,60){\line(1,0){15}}}
\put(289,-8){$15000$}

\textcolor{red}{\put(300,60){\vector(-1,0){0}}}

\end{picture}
\end{center}
\caption{An Counterexample of Scenario (iv).}
\label{f:counterexample}
\end{figure}

\subsection{Soundness and Completeness of the Analysis}
We call an analysis method \emph{sound} if any counterexample found
using such a method is a real counterexample of the question, and
\emph{complete} if the fact that no counterexample can be found using
such a method implies no counterexample exist for the question in
analysis. The soundness of our results is easy to check, simply by
examining the counterexamples found. But this is not the case for
completeness, since we choose instantiating our model on dense time
domain to make it more real but giving rise to an infinite state space
which is unfeasible to exhaust. In general, completeness of untimed
model checking cannot be achieved for any systems, any time sampling
stategies and any properties. However, \"Olveczky and Meseguer proved
the completeness of untimed temporal logic model checking, under the
maximal time sampling strategy, for a large class of real-time
systems:
\begin{theorem}
\label{t:completeness}
Given a \emph{time-robust} real-time rewrite theory $\cal R$, a set
$P$ of \emph{tick-stabilizing} atomic propositions, an LTL formula
$\Phi$ (excluding the \emph{next} operator $\bigcirc$) whose atomic
propositions are contained in $P$. The untimed temporal logic model
checking verifying $\Phi$ is \emph{complete} under the maximal time
sampling stategy.
\end{theorem}

To apply Theorem~\ref{t:completeness} on our analysis to show the
completeness, we only need to prove time-robustness of our model and
tick-stabilization of our defined atomic propositions,
\verb|taskTimeout| and \verb|scheduleCorrectly|. The latter is quite
trivial, while the former requires little adjustments to the model,
which collapse the possible finishing interval for some periodic task
into a single value that should be assigned to the possible maximum
computation time. Then we can apply Lemma~\ref{l:timerobustness} to
prove the time-robustness of our (adjusted) model.
\begin{lemma}
\label{l:timerobustness}
An object-oriented specification $\cal R$, with a conventional tick
rule, is \emph{time-robust} if the following conditions are satisfied
for all appropriate \emph{ground} terms $t$ and $r,r'$:

\noindent
(i) $mte(\delta(t,r))=mte(t)\dotdiv r$, for all $r\le mte(t)$;

\noindent
(ii) $\delta(t,0)=t$;

\noindent
(iii) $\delta(\delta(t,r),r')=\delta(t,r+r')$, for $r+r'\le mte(t)$;

\noindent
(iv) $mte(\sigma(l))=0$ for each ground instance $\sigma(l)$ of a
left-hand side of an instantaneous rewrite rule.
\end{lemma}

We achieve the same verification results for the adjusted model as for
the original one: schedulability and correctness hold in Scenarios
(i-iii) but fail in Scenario~(iv). The only thing remained to show the
completeness of our results is to prove the reasonability of the
adjustments, that is, if a set of tasks (including system ones) is
schedulable when the computation time of some task $\tau_i$ in it
equals to $C_i^{max}$, then when some jobs of $\tau_i$ become possible
to finish in time $r\le C_i^{max}$, the set of tasks remains still
schedulable. This is done by proving Lemma~\ref{l:max} and considering
\verb|scheduling| and \verb|switching| as having same and higher
priority than all periodic tasks.
\begin{lemma}
\label{l:max}
Assume the time $r_s$ at which a job of $\tau_i$ starts running is
fixed. The time $r_f$, at which this job finishes, reaches its maximum
if all job instances of tasks $\tau$'s, the priorities of which are
higher than or equal to that of $\tau_i$, running between $r_s$ and
$r_f$ finish in their maximum possible computation time.
\end{lemma}


\section{Related Work}
\label{s:relate}
In this section we discuss our results with related work in two
directions.

Considering schedulability test, Liu and Layland gave
in~\cite{DBLP:journals/jacm/LiuL73} the famous sufficient condition
that a set of periodic tasks is schedulable with respect to RMS if
$\displaystyle \Sigma^n_{i=1} C_i/T_i \le n(2^{1/n}-1)$ holds, where
$C_i$ and $T_i$ are the computation time and the period of task
$\tau_i$ respectively. Then in~\cite{DBLP:journals/tc/BiniBB03}, a
more sufficient condition, known as \emph{Hyperbolic Bound}, which has
the same complexity as Liu and Layland's one, was proposed by Bini et
al. On the other hand, necessary and sufficient conditions for
schedulability were derived independently
in~\cite{DBLP:journals/rts/SpruntSL89} and~\cite{audsley1993deadline},
requiring more sophisticated analysis on the task set. Nevertheless,
these results take no overhead into account, being not as realistic as
ours. Katcher et al. did consider overhead in their schedulability
analysis under several models based on different kinds of popular
implementations~\cite{DBLP:journals/tse/KatcherAS93}. But as we
mentioned at the very beginning, the ways to implement the RMS
algorithm are countless, hence their analysis could not be applied on
our target implementation. Furthermore, comparing with those
theoretical analysis, our method by formal modeling and verification
has a great advantage that if our schedulability test answers ``no'',
it returns at the same time a real counterexample, which is able to
guide our engineer to adjust the design.

\cite{DBLP:conf/iceccs/CuiDT14} and~\cite{TianD2011} also made use of
model checking to analyze the RMS algorithm along the same line with
different languages and tools. They only considered the ideal setting
as in~\cite{DBLP:journals/jacm/LiuL73}, but not an implementation
which contains much more details. Our model of the implementation
easily degenerates to a model of the RMS algorithm, if we let the time
for scheduling and switching be zero and let the possible finishing
interval of each task be a single value.

Finally, Maude and Real-Time Maude have been successfully applied on
large numbers of applications~\cite{DBLP:journals/jlp/Meseguer12},
especially on communication protocols, real-time and cyber-physical
systems. But few results are achieved on scheduling problems. RMS is
investigated using Real-Time Maude for the first time.

\section{Conclusion}
\label{s:conclusion}
We have formally modeled a realistic implementation of RMS algorithm,
obtained from our industrial partner, using Real-Time Maude, a
modeling language based on rewriting logic. By taking into acount the
overhead of scheduling and switching, assuming the possible
computation time for each task may not be constant, we believe that
our model has enough details to be analyzed for the behaviours of the
real system. Two important properties--schedulability and
correctness--are verified by model checking on the model, under
several given scenarios. We also prove at last the soundness and
completeness of our analysis.


\bibliographystyle{splncs03} \bibliography{submission}
\end{document}

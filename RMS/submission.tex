% This is LLNCS.DOC the documentation file of
% the LaTeX2e class from Springer-Verlag
% for Lecture Notes in Computer Science, version 2.4
\documentclass{llncs}
\usepackage{alltt}
\usepackage{amsmath}
%\usepackage{llncsdoc}
%
\begin{document}
%\thispagestyle{empty}
%\begin{flushleft}
%\end{flushleft}

\title{Formal Analysis of Rate-Monotonic Scheduling Implementation via Real-Time Maude}
\author{Jiaxiang Liu\inst{1,2}}
\institute{School of Software, Tsinghua University, Beijing, China
  \and \'Ecole Polytechnique, Palaiseau, France}
\maketitle
\thispagestyle{empty}

\section{Introduction}

\section{Real-Time Maude}

Real-Time Maude is a language and tool that extends Maude to support
the formal specification and analysis of real-time systems.

\subsection{Specification}

A Real-Time Maude module specifies a \emph{real-time rewrite theory}
$(\Sigma, E\cup A , IR, TR)$, where:

\begin{itemize}
\item $\Sigma$ is an algebraic \emph{signature}, that is, a set of
  declarations of \emph{sorts}, \emph{subsorts} and \emph{function
    symbols}.

\item $(\Sigma, E\cup A)$ is a \emph{membership equational logic
  theory}, with $E$ a set of possibly conditional equations, and $A$ a
  set of equational axioms such as associativiy, commutativity and
  identity.  $(\Sigma, E\cup A)$ specifies the system's state space as
  an algebraic data type, and includes a built-in specification of a
  sort \verb|Time|.

\item $IR$ is a set of \emph{labeled conditional rewrite rules}
  specifying the system's local transitions, each of which has the
  form $[l]~:~t\rightarrow t'\mbox{ \textbf{if}
  }\bigwedge^n_{j=1}cond_j$, where each $cond_j$ is an equality
  $u_j=v_j$, and $l$ is a \emph{label}. Such a rule specifies an
  \emph{instantaneous transition} from an instance of $t$ to the
  corresponding instance of $t'$, \emph{provided} the conditions hold.

\item $TR$ is a set of \emph{tick rules} $[l]~:~\{t\}\rightarrow\{t'\}
  \mbox{ \textbf{in time} }\tau\mbox{ \textbf{if} }cond$ that advance
  time in the \emph{entire} state $t$ by $\tau$ time units.
\end{itemize}

A class declaration $\texttt{class }C\texttt{ |
}att_1\texttt{:}s_1\texttt{,}\ldots\texttt{,}att_n\texttt{:}s_n$
declares a class $C$ with attributes $att_1$ to $att_n$ of sorts $s_1$
to $s_n$. An \emph{object} of class $C$ in a given state is
represented as a term $\texttt{< } O\texttt{:} C \texttt{ | }
att_1\texttt{:}val_1\texttt{,} \ldots
\texttt{,}att_n\texttt{:}val_n\texttt{ >}$ of sort \verb|Object|,
where $O$, of sort \verb|Oid|, is the object's \emph{identifier}, and
where $val_1$ to $val_n$ are the current values of the attributes
$att_1$ to $att_n$. A \emph{subclass} inherits all the attributes and
rules of its superclasses.

\subsection{Formal Analysis}
In this paper, we only consider Real-Time Maude's \emph{linear
  temporal logic model checker}, which analyzes whether \emph{each}
behavior satisfies a temporal logic formula. \emph{State propositions}
are terms of sort \verb|Prop|, and their symantics is defined by
equations $\texttt{ceq } statePattern \texttt{ |= } prop \texttt{ = }
b \texttt{ if } cond$, with $b$ a term of sort \verb|Bool|, stating
that $prop$ evaluates to $b$ in states that are instances of
$statePattern$ when the condition $cond$ holds. These equations
together define $prop$ to hold in all states $t$ where $t \texttt{ |=
} prop$ evaluates to \verb|true|. A temporal logic \emph{formula} is
constructed by state propositions and temporal logic operators such as
\verb|True|, \verb|False|, \verb|~|(negation), \verb|/\|, \verb|\/|,
\verb|->|(implication), \verb|[]|(``always''),
\verb|<>|(``eventually'') and \verb|U|(``until''). Real-Time Maude
provides both \emph{unbounded} and \emph{time-bounded} LTL model
checking. The time-bounded model checking command
\begin{alltt}
  (mc \(t\) |=t \(formula\) in time <= \(timeLimit\) .)
\end{alltt}
checks whether the temporal logic formula holds in all behaviors up to
duration $timeLimit$ starting from the initial state $t$.

\section{Rate-Monotonic Scheduling Algorithm and the Implementation}

\subsection{Formulation of the Standard Setting}
The frequently used setting of the RMS algorithm for analysis
considers a task set consisting only of $n$ periodic tasks
$\tau_1,\ldots,\tau_n$. Task $\tau_i$ has a period $T_i$ and a
computation time $C_i$. First jobs of all tasks are assumed to be
instantiated simultaneously.  This means that jobs corresponding to
task $\tau_i$ are initiated at times $kT_i, k\ge 0$. The job initiated
at time $kT_i$ has $(k+1)T_i$ as its deadline, the initiation time of
the next job. The RMS algorithm chooses the labeling such that $T_1\le
T_2\le \ldots \le T_n$. Consequently, $\tau_i$ receives priority
$i$. The following assumptions are made:

(A1) Computation time $C_i$ for each task $\tau_i$ is constant and
does not vary with time.

(A2) Tasks are independent, such that they are ready to run at their
initiation times and can be preempted instantly (ignoring all
blocking).

(A3) All overhead, such as task swapping times, is ignored.


\section{Formalizing the RMS Implementation}

\section{Formal Analysis}
\subsection{Properties}
\subsection{Completeness of the Analysis}

\section{Related Work}

\section{Conclusion}


\end{document}

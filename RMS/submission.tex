% This is LLNCS.DOC the documentation file of
% the LaTeX2e class from Springer-Verlag
% for Lecture Notes in Computer Science, version 2.4
\documentclass{llncs}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
%\usepackage{llncsdoc}

\newcommand{\hide}[1]{\ignorespaces}

\begin{document}
%\thispagestyle{empty}
%\begin{flushleft}
%\end{flushleft}

\title{Formal Analysis of Rate-Monotonic Scheduling Implementation via Real-Time Maude}
\author{Jiaxiang Liu\inst{1,2}}
\institute{School of Software, Tsinghua University, Beijing, China
  \and \'Ecole Polytechnique, Palaiseau, France}
\maketitle
\thispagestyle{empty}

\section{Introduction}

\section{Rate-Monotonic Scheduling Algorithm and the Implementation}

\subsection{Formulation of the Standard Setting}
The frequently used setting of the RMS algorithm for analysis
considers a task set consisting only of $n$ periodic tasks
$\tau_1,\ldots,\tau_n$. Task $\tau_i$ has a period $T_i$ and a
computation time $C_i$. First jobs of all tasks are assumed to be
instantiated simultaneously. This means that jobs corresponding to
task $\tau_i$ are initiated at times $kT_i, k\ge 0$. Deadlines consist
of runability constraints only, that is, the job initiated at time
$kT_i$ has $(k+1)T_i$ as its deadline, which is the initiation time of
the next job. The RMS algorithm chooses the labeling such that $T_1\le
T_2\le \ldots \le T_n$. Consequently, $\tau_i$ receives priority
$i$. The following assumptions are made:

(A1) Computation time $C_i$ for each task $\tau_i$ is constant and
does not vary with time.

(A2) Tasks are independent, such that they are ready to run at their
initiation times and can be preempted instantly (ignoring all
blocking).

(A3) All overhead, such as task switching times, is ignored.

In this paper, we consider an implementation instead of the RMS
algorithm itself, thus the model would be more complicated than this
ideal formulation.  Assumptions~(A1) and (A3) will be relaxed to shape a more
realisitc analysis model, as shown below.

\subsection{The Implementation of RMS}
The algorithm of the RMS is straightforward, and it is easy to
implement it in pratical systems. However, the way to implement it is
not unique. Our target implementation to analyze is part of a
realistic avionic operating system from our industrial
partner. Interrupts triggered by the clock would come every $T$, which
we call \emph{interrupt cycle}. When an interrupt request comes, if
the system is interruptable, i.e. the interrupt mask is cleared, the
function $schedule()$ will be called; otherwise the handler function
$schedule()$ will be pending until the interrupt mask becomes cleared.
The pseudocode of $schedule()$ is shown as Algorithm~\ref{a:schedule},
where $taskList$ is the list of periodic tasks, which are needed to be
scheduled, and assumed ordered descendingly by priorities, and where
both variables $taskList$ and $timer$ are global. In this
implementation, there is only one kind of interrupt, the period $T_i$
of each task is a multiple of $T$, and the tasks are independent,
meeting assumption~(A2).

\begin{algorithm}
  \caption{The C-Like Pseudocode of $schedule()$}
  \label{a:schedule}
  \begin{algorithmic}[1]
\Function{$schedule$}{$ $}{}
  \State \Call{$int\_o\!f\!\!f$}{$ $}; \Comment{to disable interrupts}
  \State \Call{$updateStatus$}{$taskList$}; \label{l:updatestatus}
  \State $timer = timer + 1$; \label{l:timer} \label{l:inc}
  \State $p = taskList$;
  \While{$p$} \label{l:startrun1st}
    \If{$p\rightarrow status == \textit{INTERRUPT}$}
      \State \Return;
    \ElsIf{$p\rightarrow status == \textit{READY}$}      
      \State $p\rightarrow status = \textit{RUNNING}$;
      \State \Call{$int\_on$}{$ $}; \Comment{to enable interrupts} \label{l:endrun1st}
      \State $p\rightarrow function()$; \Comment{to run the task} \label{l:function}
      \State \Call{$int\_o\!f\!\!f$}{$ $};
      \State $p\rightarrow status = \textit{DORMANT}$;
    \EndIf
    \State $p = p\rightarrow next$;
  \EndWhile
\EndFunction
\Function{$updateStatus$}{$p$}
  \While{$p$}
    \If{$p\rightarrow status == \textit{RUNNING}$} \label{l:startupdate}
      \State $p\rightarrow status = \textit{INTERRUPT}$;
    \EndIf
    \If{$timer~\%~(p\rightarrow period) == 0$} \Comment{the task should be initiated}
      \If{$p\rightarrow status == \textit{DORMANT}$} 
        \State $p\rightarrow status = \textit{READY}$;
      \Else \Comment{the status is \textit{READY} or \textit{INTERRUPT}}
	\State \Call{$reportTaskError$}{$p$}; \Comment{the task misses its deadline}
      \EndIf
    \EndIf \label{l:endupdate}
    \State $p = p\rightarrow next$;
  \EndWhile
\EndFunction
  \end{algorithmic}
\end{algorithm}

The function $updateStatus()$ updates status of all tasks in the list:
if the task is running when the interrupt is handled, it becomes
interrupted\footnote{Note that the status \textit{INTERRUPT} indicates
  the task is interrupted for the moment, or was interrupted before
  but is not finished running yet.}; the task, which is at its
initiated time, would be set to be ready if its previous corresponding
job is finished, or produce an error otherwise. Notice that
$schedule()$ is called only when the periodic interrupt is handled. It
can be also interrupted while running some task (Line~\ref{l:function}
in Algorithm~\ref{a:schedule}), such that the running of $schedule()$
can be nested.

\section{Real-Time Maude}
Real-Time Maude is a language and tool that extends Maude to support
the formal specification and analysis of real-time systems.

\subsection{Specification}
A Real-Time Maude module specifies a \emph{real-time rewrite theory}
$(\Sigma, E\cup A , IR, TR)$, where:
\begin{itemize}
\item $\Sigma$ is an algebraic \emph{signature}, that is, a set of
  declarations of \emph{sorts}, \emph{subsorts} and \emph{function
    symbols}.
\item $(\Sigma, E\cup A)$ is a \emph{membership equational logic
  theory}, with $E$ a set of possibly conditional equations, and $A$ a
  set of equational axioms such as associativiy, commutativity and
  identity.  $(\Sigma, E\cup A)$ specifies the system's state space as
  an algebraic data type, and includes a built-in specification of a
  sort \verb|Time|.
\item $IR$ is a set of \emph{labeled conditional rewrite rules}
  specifying the system's local transitions, each of which has the
  form $[l]~:~t\rightarrow t'\mbox{ \textbf{if}
  }\bigwedge^n_{j=1}cond_j$, where each $cond_j$ is an equality
  $u_j=v_j$, and $l$ is a \emph{label}. Such a rule specifies an
  \emph{instaneous transition} from an instance of $t$ to the
  corresponding instance of $t'$, \emph{provided} the conditions hold.
\item $TR$ is a set of \emph{tick rules} $[l]~:~\{t\}\rightarrow\{t'\}
  \mbox{ \textbf{in time} }\tau\mbox{ \textbf{if} }cond$ that advance
  time in the \emph{entire} state $t$ by $\tau$ time units.
\end{itemize}

A class declaration $\texttt{class }C\texttt{ |
}att_1\texttt{:}s_1\texttt{,}\ldots\texttt{,}att_n\texttt{:}s_n$
declares a class $C$ with attributes $att_1$ to $att_n$ of sorts $s_1$
to $s_n$. An \emph{object} of class $C$ in a given state is
represented as a term $\texttt{< } O\texttt{:} C \texttt{ | }
att_1\texttt{:}val_1\texttt{,} \ldots
\texttt{,}att_n\texttt{:}val_n\texttt{ >}$ of sort \verb|Object|,
where $O$, of sort \verb|Oid|, is the object's \emph{identifier}, and
where $val_1$ to $val_n$ are the current values of the attributes
$att_1$ to $att_n$. A \emph{subclass} inherits all the attributes and
rules of its superclasses.

\subsection{Formal Analysis}
In this paper, we only consider Real-Time Maude's \emph{linear
  temporal logic model checker}, which analyzes whether \emph{each}
behavior satisfies a temporal logic formula. \emph{State propositions}
are terms of sort \verb|Prop|, and their symantics is defined by
equations $\texttt{ceq } statePattern \texttt{ |= } prop \texttt{ = }
b \texttt{ if } cond$, with $b$ a term of sort \verb|Bool|, stating
that $prop$ evaluates to $b$ in states that are instances of
$statePattern$ when the condition $cond$ holds. These equations
together define $prop$ to hold in all states $t$ where $t \texttt{ |=
} prop$ evaluates to \verb|true|. A temporal logic \emph{formula} is
constructed by state propositions and temporal logic operators such as
\verb|True|, \verb|False|, \verb|~|(negation), \verb|/\|, \verb|\/|,
\verb|->|(implication), \verb|[]|(``always''),
\verb|<>|(``eventually'') and \verb|U|(``until''). Real-Time Maude
provides both \emph{unbounded} and \emph{time-bounded} LTL model
checking. The time-bounded model checking command
\begin{alltt}
  (mc \(t\) |=t \(formula\) in time <= \(timeLimit\) .)
\end{alltt}
checks whether the temporal logic formula holds in all behaviors up to
duration $timeLimit$ starting from the initial state $t$.

\section{Formalizing the RMS Implementation}
Based on the code, we model the implementation under the following
assumptions:

(A1') Computation time $C_i$ for each task $\tau_i$ is not constant,
varying randomly between minimum $C^{min}_i$ and maximum $C^{max}_i$.

(A2) Tasks are independent, such that they are ready to run at their
initiation times and can be preempted instanly.

(A3') The times for scheduling and task switching should be
considered, while other overhead is ignored.

These assumptions make our model different with the standard
formulation. For instance, due to the interrupt masking and
consideration of scheduling overhead, jobs corresponding to task
$\tau_i$ could not be initiated at exactly $kT_i$, but a bit later.
Note that (A2) says jobs are ready to run at their initiation times,
however, they cannot run at their initiation times, because scheduling
takes time.

\subsection{Some Basic Data Types}
In our model, tasks are identified with their indexes of sort
\verb|Nat| in the $taskList$. We define a sort \verb|MaybeNat|
wrapping \verb|Nat|s to refer to some task, with \emph{constructor}
\verb|some| followed by a \verb|Nat| $n$ indicating the task with
index $n$, and \verb|none| for no task:
\begin{verbatim}
  op none : -> MaybeNat [ctor] .
  op some_ : Nat -> MaybeNat [ctor] .
\end{verbatim}

A sort \verb|Stack| is introduced to simulate the stack of the system,
storing the tasks that are being interrupted, and equipped with
operations \verb|push|, \verb|pop| and \verb|peek| on it.
\begin{verbatim}
  op bottom : -> Stack [ctor] .
  op _#_ : Nat Stack -> Stack [ctor] .
\end{verbatim}

We also need a sort \verb|Interval| denoting the interval, within
which the computation time of a task varies and which we call
\emph{possible finishing interval}, and a sort \verb|Counter| to
represent the time some task has been running and the corresponding
possible finishing interval.
\begin{verbatim}
  op [_,_] : Time Time -> Interval [ctor] .
  op [_/_] : Time Interval -> Counter [ctor] .
\end{verbatim}

At last, to make our model checkable by \emph{untimed model-checking},
it is reasonable to reset the global variable $timer$ when it reaches
an upperbound while increasing (see Line~\ref{l:timer} in
Algorithm~\ref{a:schedule}) in the model. Then $timer$ is of sort
\verb|Timer| and the upperbound would be the least common multiple of
the periods of all tasks.
\begin{verbatim}
  op [_/_] : Nat NzNat -> Timer [ctor] .
\end{verbatim}

\subsection{Modeling the System States}
Abstracting from some details, the running system could be considered
as consisting of several parts: the tasks which are scheduled, the
scheduler itself, the hardware including registers and stacks, and the
interrupt source. The scheduler, i.e. the function $schedule()$, has
only the variable $timer$ to be interesting, thus it can be described
by a single variable. We will present the modeling of the other parts
one by one.

\subsubsection{Tasks}
In this paper, since we are trying to analyze the implementation of
the scheduler, each task will be abstracted from its functionality and
treated as a \verb|Counter|. As mentioned above, times for scheduling
and task switching will be also considered in the model. They are just
seen as two system tasks. Every task is modeled as an object instance
of some subclass of the base class \verb|Task|:
\begin{verbatim}
  class Task | cnt : Counter .
  op error : -> Object [ctor] .
\end{verbatim}
The attribute \verb|cnt| denotes the computation time of the task,
while \verb|error| is an object indicating some task which misses its
deadline.

A periodic task, which is needed to be scheduled, is an object
instance of the subclass \verb|PTask| with additional attributes
\verb|priority|, \verb|period| and \verb|status|:
\begin{verbatim}
  class PTask | priority : Nat, period : NzNat, status : Status .
  subclass PTask < Task .
\end{verbatim}
where \verb|Status| is a sort with four constant constructors, just as
in the implementation:
\begin{verbatim}
  ops RUNNING INTERRUPT READY DORMANT : -> Status [ctor] .
\end{verbatim}
The list of periodic tasks, the variable $taskList$ in the
implementation, is modeled as an instance of the sort \verb|TaskList|,
which is a list of \verb|PTask|s\footnote{Following the Maude
  convention, variables would be written in capital letters.}:
\begin{verbatim}
  op null : -> TaskList [ctor] .
  op _::_ : Object TaskList ~> TaskList [ctor] .
  mb (< O:Oid : PTask |> :: L:TaskList) : TaskList .
  mb (error :: L:TaskList) : TaskList .
\end{verbatim}
As mentioned already, periodic tasks would be identified by their
indexes in the list.

On the other hand, a system task is an object instance of the subclass
\verb|SysTask| of \verb|Task| with no extra attributes:
\begin{verbatim}
  class SysTask .            subclass SysTask < Task .
\end{verbatim}
Different from periodic tasks, system tasks would be organized in a
multiset of sort \verb|SysTasks|, and identified by their \verb|Oid|s.
We abstract here from the detailed definitions thanks to the
similarity.

\subsubsection{Hardware} Our model considers two parts of hardware relating
to the interrupt handling inside the system, the registers and the
stack.

The set of registers is modeled as an object instance of the class
\verb|Regs|, with attributes \verb|pc| denoting the program counter,
\verb|mask| for the interrupt masking flag and \verb|ir| for the
interrupt request flag.
\begin{verbatim}
  class Regs | pc : TaskID, mask : Bool, ir : Bool .
\end{verbatim}
where the sort \verb|TaskID| is a supersort of \verb|MaybeNat| and
\verb|Oid|, referring to some task.
\begin{verbatim}
  subsorts MaybeNat Oid < TaskID .
\end{verbatim}

Some operations, such as \verb|getPc|, \verb|setMask| and so on, are
also defined on the class \verb|Regs|.

Then the hardware is naturally described by the sort \verb|Hardware|:
\begin{verbatim}
  op [_;_] : Object Stack ~> Hardware [ctor] .
  mb ([ < O:Oid : Regs |> ; S:Stack ]) : Hardware .
\end{verbatim}

\subsubsection{Interrupt Source}
The interrupt source is modeled in our model as an object of class \verb|IntSrc|,
with attribute \verb|cycle| denoting the interrupt cycle:
\begin{verbatim}
  class IntSrc | val : Time, cycle : Time .
\end{verbatim}

\subsubsection{System}
The system in the model is just a composition of the parts introduced
above, with a sort \verb|System|\footnote{Some variable declarations
  are not shown for simplicity.}:
\begin{verbatim}
  op _____ : 
       TaskList Timer SysTasks Hardware Object ~> System [ctor] .
  mb (L T STS HW < O:Oid : IntSrc |>) : System .
\end{verbatim}

\subsection{Interrupt Requesting}
Interrupt requests are performed by the source exactly every cycle
$T$, when the attribute \verb|val| decreases to \verb|zero| while time
advances. This is modeled by the following instaneous conditional rule
applied on \verb|System|:
\begin{verbatim}
  crl [interrupt-request] :
    (L T STS HW ISRC) => (L T STS (HW).intReq reset(ISRC))
    if (ISRC).timeout .
\end{verbatim}
where the operator \verb|_.timeout| examines whether the attribute
\verb|val| equals to \verb|zero|, and \verb|_.intReq| sets the
\verb|ir| flag indicating there is an interrupt request to be handled:
\begin{verbatim}
  op _.intReq : Hardware -> Hardware .
  eq [ REGS ; S ].intReq = [ (REGS).setIr ; S ] .
\end{verbatim}
Then the request will wait to be handled, which is explained in
Section~\ref{ss:inthandling}.


\subsection{Task Initiation}
Periodic tasks are initiated sequently by exactly the function
$updateStatus()$ in Algorithm~\ref{a:schedule}, which is modeled by
the recursive operation as below:
\begin{verbatim}
  op updateStatus_with_ : TaskList Timer -> TaskList . 
  eq updateStatus null with TIMER = null .
  eq updateStatus (TASK :: L) with TIMER
       = (update TASK with TIMER) :: (updateStatus L with TIMER) .
\end{verbatim}
with \verb|TIMER| the current value of the global variable $timer$,
and \verb|update_with_| updating the status of individual task
(Lines~\ref{l:startupdate}-\ref{l:endupdate} in
Algorithm~\ref{a:schedule})
\begin{verbatim}
  op update_with_ : Object Timer ~> Object .
  ceq update < O : PTask | period : T, status : ST > with TIMER
        = if ST == DORMANT then < O : PTask | status : READY >
          else error fi
      if TIMER rem T == 0 .
  eq update < O : PTask | status : ST > with TIMER
       = if ST == RUNNING then < O : PTask | status : INTERRUPT >
         else < O : PTask |> fi [owise] .
\end{verbatim}
In the case where \verb|TIMER|($timer$) can be divided by the task's
period, i.e. the task should be initiated, if the status is
\verb|DORMANT|, it should be ready to run; otherwise it means the
previous job of the task is not finished, thus it misses its deadline,
producing an \verb|error|. In the other case where the tasks should
not be initiated, the status of the task changes only if it is
\verb|RUNNING|. We can easily see \verb|updateStatus_with_| behaves
the same as $updateStatus()$.

\subsection{Interrupt Handling and Task Scheduling}
\label{ss:inthandling}
When an interrupt request comes, it may not be ``seen'' immediately by
the system. It requires the \verb|mask| flag to be cleared. Once the
request is seen, it is handled by performing two stages: the interrupt
mechanism of the hardware (such as clearing \verb|ir|, pushing context
into stack and so on) and running the $schedule()$ function. This is
modeled by the following instaneous rewrite rule:
\begin{verbatim}
  crl [interrupt-handle] :
    SYSTEM => ((SYSTEM).interrupt).startScheduling
    if (SYSTEM).existInt .
\end{verbatim}
where \verb|_.existInt| checks whether \verb|mask| is cleared
\emph{and} \verb|ir| is set. The operation \verb|_.interrupt| models
the interrupt mechanism performed by the hardware and does four
things: (i)clearing the \verb|ir| flag, which means the request has
been handled; (ii)pushing the current \verb|pc| value into the stack,
storing the interrupted context; (iii)assigning \verb|scheduling| of
sort \verb|Oid| to \verb|pc|, which indicates that $schedule()$ is
running; and (iv)setting the \verb|mask| flag, to mask the coming
interrupt requests. As for \verb|_.startScheduling|, it performs
updating the status of $taskList$ and increasing $timer$ by $1$,
corresponding to Line~\ref{l:updatestatus} and \ref{l:inc} in
Algorithm~\ref{a:schedule}.
\begin{verbatim}
  op _.startScheduling : System -> System .
  eq (L T STS HW ISRC).startScheduling 
       = ((updateStatus L with T) inc(T) STS HW ISRC) .
\end{verbatim}

It is worth pointing out here that \emph{scheduling} in our model does
not refer to the stage in which $schedule()$ is running. We use it to
refer to, for simplicity, the stage scheduling the first should-be-run
periodic task, i.e.  the code strictly before Line~\ref{l:function} in
Algorithm~\ref{a:schedule}. Therefore,
\begin{definition}
  The \emph{scheduling time} talked about in this paper consists of
  the time for switching from a running task to the function
  $schedule()$ when handling interrupts, the time spent by
  $schedule()$ finding and setting the \emph{first} should-be-run
  periodic task, and the time for switching from $schedule()$ to that
  first should-be-run task.
\end{definition}
Similarly, \emph{switching} in our model refers to the stage finding
out the next should-be-run periodic task when one is finished.
\begin{definition}
  The \emph{switching time} in this paper consists of the time for
  switching from a finished task back into $schedule()$, the time
  spent by $schedule()$ finding and setting the \emph{next}
  should-be-run periodic task, and the time for switching from
  $schedule()$ to that next should-be-run task.
\end{definition}

With our terminology, when the running time of the system task
\verb|scheduling| reaches its possible finishing interval, the
following rule may apply to finish the scheduling stage:
\begin{verbatim}
  crl [scheduling-finish] :
    (L T STS HW ISRC) => (SYSTEM).finishScheduling
    if SYSTEM := (L T STS HW ISRC) 
       /\ (SYSTEM).running == scheduling 
       /\ scheduling mayFinish?in STS .
\end{verbatim}
where operation \verb|_.running| returns the current \verb|pc| value
of the system and \verb|_mayFinish?in_| checks if the running time of
the task reaches its possible finishing interval:
\begin{verbatim}
  op _mayFinish?in_ : Oid SysTasks ~> Bool .
  eq O mayFinish?in [ < O : SysTask | cnt : C > REST ] 
       = C mayFinish? .
  op _mayFinish? : Counter -> Bool .
  eq [ R / [ MIN , MAX ] ] mayFinish?
       = if R lt MIN then false else true fi .
\end{verbatim}
And the operation \verb|_.finishScheduling| performs the remaining
instructions, which are left by \verb|_.startScheduling|, in the
scheduling stage: finding the first should-be-run periodic task and
setting it to run (Line~\ref{l:startrun1st}-\ref{l:endrun1st} in
Algorithm~\ref{a:schedule}).
\begin{verbatim}
  op _.finishScheduling : System -> System .
  eq (L T STS HW ISRC).finishScheduling
       = (L T (finish scheduling in STS) HW ISRC).run1stTask .
\end{verbatim}
where \verb|finish_in_| resets the counter of task \verb|scheduling|,
and \verb|_.run1stTask| models
Line~\ref{l:startrun1st}-\ref{l:endrun1st} in
Algorithm~\ref{a:schedule}, searching the task with highest priority
that has status \verb|INTERRUPT| or \verb|READY| then performing an
\emph{interrupt return} or letting it run respectively.

Similar to \verb|scheduling|, the \verb|switching| stage starts when
the running time of the current running periodic task reaches its
possible finishing interval and finishes when its own running time
does so, with the two following similar rules:
\begin{verbatim}
  crl [task-finish] :
    (L T STS HW ISRC) => (SYSTEM).startSwitching
    if SYSTEM := (L T STS HW ISRC)
       /\ some N := (SYSTEM).running
       /\ some N mayFinish?in L .
  crl [switching-finish] :
    (L T STS HW ISRC) => (SYSTEM).finishSwitching
    if SYSTEM := (L T STS HW ISRC)
       /\ (SYSTEM).running == switching
       /\ switching mayFinish?in STS .
\end{verbatim}

\subsection{Timed Behaviours of the System}
\emph{Timed behaviours} of the system consist of two parts, the
running of tasks, including both periodic ones and system ones, and
the running of interrupt source. These are all modeled as the
following one conventional tick rule:
\begin{verbatim}
  crl [tick]:
    {SYSTEM} => {delta(SYSTEM, R)} in time R 
    if R le mte(SYSTEM) [nonexec] .
\end{verbatim}
where \verb|delta| defines the effects of time elapse on the system,
and \verb|mte| denotes the maximum amount of time allowed to elapse
from the current state until an instaneous transition \emph{must} be
performed. Notice that the variable $R$ is \emph{continuous} with
respect to the specific time domain\footnote{Real-Time Maude contains
  built-in modules to define the time domain to be natural numbers and
  rational numbers, specifying \emph{discrete} time domains and
  \emph{dense} time domains respectively.}  that we choose to
instantiate the model on, which is different from timed automata that
discretize dense time by defining ``clock region''.

Time affects the system by advancing both the running task, whose $ID$
is loaded at \verb|pc|, and the interrupt source simultaneously,
increasing their \verb|cnt| and \verb|val| respectively:
\begin{verbatim}
  ceq delta((L T STS HW ISRC), R)
        = ((deltaTask(ID, L, R) T STS HW (deltaIS(ISRC, R)))
      if ID := (HW).getPc /\ ID :: MaybeNat .
\end{verbatim}
We ease the reading by not showing the case where $ID$ is of sort
\verb|Oid|, due to similarity. At that case, \verb|deltaTask| applies
on \verb|STS| instead of \verb|L|.

The maximum amount of time allowed to elapse depends on three aspects:
the time remained to finish the running task, either periodic one or
system one, the time remained to request an interrupt, and whether or
not there exists a non-masked interrupt request for the moment:
\begin{verbatim}
  ceq mte(L T STS HW ISRC)
        = minimum( mteTask(ID, L),
                   minimum( mteIS(ISRC), mteIr(HW)))
      if ID := (HW).getPc /\ ID :: MaybeNat .
\end{verbatim}
where \verb|mteIr| will return \verb|zero| if there exists a
non-masked interrupt request in the system, or \verb|INF| which
represents \emph{infinity} otherwise. Again we do not show the case
where $ID$ is of sort \verb|Oid|, which is very similar. We should
point out that \verb|mteTask| computes the time remained to reach the
maximum of the possible finishing interval of the task, since it is
the time until which a ``finish'' transition \emph{must} happen.

\section{Formal Analysis}
\subsection{Properties}
\subsection{Completeness of the Analysis}

\section{Related Work}

\section{Conclusion}


\end{document}

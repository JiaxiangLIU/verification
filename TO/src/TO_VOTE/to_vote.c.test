

/**
 * @file to_comm.c
 * @brief 通信板业务进程入口
 * @author danny
 * @date 2015.1.26
 **/

#include <stdio.h>
#include <stdlib.h>

#include "global.h"
#include "to_init.h"
#include "vote_init.h"
#include "log.h"
#include "to_status.h"
#include "ctrbox_comm.h"
#include "vote_event_handle.h"
#include "pthread.h"
#include "control_box.h"

RT_DATA rt_data;
pthread_mutex_t rt_mutex = PTHREAD_MUTEX_INITIALIZER;
int temp_gear = 0;
MANUAL_TO_AUTO_FLAG manual_to_auto_flag = {PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0};
AUTO_TO_MANUAL_FLAG auto_to_manual_flag = {PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0};
CTRL_STATUS_FLAG ctrl_status_flag = {PTHREAD_MUTEX_INITIALIZER,0};


int main(void)
{
	rt_data.rt_par.rt_v = 30;
	rt_data.rt_status.rt_trip_status = RT_DUTY;
	rt_data.rt_status.rt_enable_status = RT_AUTO_ENABLE;
	rt_data.rt_status.rt_airbrake_status = DISABLE;
	rt_data.rt_par.rt_gear = 5;

	//////////////////////////////////////////////////////////
	int ret2;
	pthread_t tid2;
	pthread_attr_t attr2;

	if ((pthread_attr_init(&attr2)) < 0) {

		printf("pthread error!:init\n");
		return 0;
	}
	pthread_attr_setdetachstate(&attr2, PTHREAD_CREATE_DETACHED);

	ret2 = pthread_create(&tid2, &attr2, manual_to_auto, NULL);

	if (ret2 != 0 ) {
		printf( "Create thread failed!\n");
		return 0;
	}

	/* 创建自动转手动处理线程 */
	int ret3;
	pthread_t tid3;
	pthread_attr_t attr3;

	if ((pthread_attr_init(&attr3)) < 0) {

		printf("pthread error!:init\n");
		return 0;
	}
	pthread_attr_setdetachstate(&attr3, PTHREAD_CREATE_DETACHED);

	ret3 = pthread_create(&tid3, &attr3, auto_to_manual, NULL);

	if (ret3 != 0 ) {
		fprintf(stderr, "Create thread failed!\n");
		return 0;
	}

	///////////////////////////////////////////////////////////

	if(ctrl_status_flag.ctrl_flag == 0) {
		pthread_mutex_lock(&(manual_to_auto_flag.mta_mutex));
		manual_to_auto_flag.mta_flag = 1;
		pthread_cond_signal(&(manual_to_auto_flag.mta_cond));
		pthread_mutex_unlock(&(manual_to_auto_flag.mta_mutex));
	}

	sleep(5);

	pthread_mutex_lock(&(rt_mutex));
	rt_data.rt_par.rt_gear = SWITCH_GEAR;
	pthread_mutex_unlock(&(rt_mutex));
	printf("司机切换到0档...\n");

	/* 得到当前的控车状态 */
	while(ctrl_status_flag.ctrl_flag == 0);
	pthread_mutex_lock(&(ctrl_status_flag.ctrl_mutex));
	printf("当前控制状态为：%d\n", ctrl_status_flag.ctrl_flag);
	pthread_mutex_unlock(&(ctrl_status_flag.ctrl_mutex));
	printf("\n");


	sleep(5);
	pthread_mutex_lock(&(rt_mutex));
	rt_data.rt_status.rt_airbrake_status = ENABLE;
	if(rt_data.rt_status.rt_airbrake_status == ENABLE) {
		pthread_mutex_lock(&(auto_to_manual_flag.atm_mutex));
		auto_to_manual_flag.atm_flag = 1;
		pthread_cond_signal(&(auto_to_manual_flag.atm_cond));
		pthread_mutex_unlock(&(auto_to_manual_flag.atm_mutex));
	}
	pthread_mutex_unlock(&(rt_mutex));

	while(ctrl_status_flag.ctrl_flag == 1);
	pthread_mutex_lock(&(ctrl_status_flag.ctrl_mutex));
	printf("当前控制状态为：%d\n", ctrl_status_flag.ctrl_flag);
	pthread_mutex_unlock(&(ctrl_status_flag.ctrl_mutex));

	while(1);
	return 0;
}

